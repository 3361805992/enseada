
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/enseadaio/enseada/cmd/enseada-server/boot/boot.go (0.0%)</option>
				
				<option value="file1">github.com/enseadaio/enseada/cmd/enseada-server/boot/database.go (0.0%)</option>
				
				<option value="file2">github.com/enseadaio/enseada/cmd/enseada-server/boot/storage.go (0.0%)</option>
				
				<option value="file3">github.com/enseadaio/enseada/cmd/enseada/get/mvnrepo.go (0.0%)</option>
				
				<option value="file4">github.com/enseadaio/enseada/cmd/enseada/get/root.go (100.0%)</option>
				
				<option value="file5">github.com/enseadaio/enseada/internal/auth/oauth_client.go (89.3%)</option>
				
				<option value="file6">github.com/enseadaio/enseada/internal/auth/oauth_client_opts.go (16.7%)</option>
				
				<option value="file7">github.com/enseadaio/enseada/internal/auth/oauth_client_store.go (9.0%)</option>
				
				<option value="file8">github.com/enseadaio/enseada/internal/auth/oauth_request.go (0.0%)</option>
				
				<option value="file9">github.com/enseadaio/enseada/internal/auth/oauth_request_store.go (0.0%)</option>
				
				<option value="file10">github.com/enseadaio/enseada/internal/auth/oidc_client.go (0.0%)</option>
				
				<option value="file11">github.com/enseadaio/enseada/internal/auth/oidc_client_opts.go (0.0%)</option>
				
				<option value="file12">github.com/enseadaio/enseada/internal/auth/oidc_session_store.go (0.0%)</option>
				
				<option value="file13">github.com/enseadaio/enseada/internal/auth/pkce_request_store.go (0.0%)</option>
				
				<option value="file14">github.com/enseadaio/enseada/internal/auth/session.go (0.0%)</option>
				
				<option value="file15">github.com/enseadaio/enseada/internal/auth/store.go (0.0%)</option>
				
				<option value="file16">github.com/enseadaio/enseada/internal/auth/user.go (0.0%)</option>
				
				<option value="file17">github.com/enseadaio/enseada/internal/auth/user_store.go (0.0%)</option>
				
				<option value="file18">github.com/enseadaio/enseada/internal/auth/v1beta1/acl_api.go (0.0%)</option>
				
				<option value="file19">github.com/enseadaio/enseada/internal/auth/v1beta1/oauth_clients_api.go (0.0%)</option>
				
				<option value="file20">github.com/enseadaio/enseada/internal/auth/v1beta1/users_api.go (0.0%)</option>
				
				<option value="file21">github.com/enseadaio/enseada/internal/couch/databases.go (0.0%)</option>
				
				<option value="file22">github.com/enseadaio/enseada/internal/couch/indexes.go (0.0%)</option>
				
				<option value="file23">github.com/enseadaio/enseada/internal/couch/migrate.go (0.0%)</option>
				
				<option value="file24">github.com/enseadaio/enseada/internal/ctxutils/values.go (0.0%)</option>
				
				<option value="file25">github.com/enseadaio/enseada/internal/guid/guid.go (85.7%)</option>
				
				<option value="file26">github.com/enseadaio/enseada/internal/maven/errors.go (0.0%)</option>
				
				<option value="file27">github.com/enseadaio/enseada/internal/maven/file.go (0.0%)</option>
				
				<option value="file28">github.com/enseadaio/enseada/internal/maven/maven.go (0.0%)</option>
				
				<option value="file29">github.com/enseadaio/enseada/internal/maven/repo.go (0.0%)</option>
				
				<option value="file30">github.com/enseadaio/enseada/internal/maven/v1beta1/api.go (0.0%)</option>
				
				<option value="file31">github.com/enseadaio/enseada/internal/middleware/headers.go (0.0%)</option>
				
				<option value="file32">github.com/enseadaio/enseada/internal/middleware/session.go (0.0%)</option>
				
				<option value="file33">github.com/enseadaio/enseada/internal/utils/http.go (0.0%)</option>
				
				<option value="file34">github.com/enseadaio/enseada/pkg/auth/boot.go (0.0%)</option>
				
				<option value="file35">github.com/enseadaio/enseada/pkg/auth/casbin_adapter.go (0.0%)</option>
				
				<option value="file36">github.com/enseadaio/enseada/pkg/auth/casbin_watcher.go (0.0%)</option>
				
				<option value="file37">github.com/enseadaio/enseada/pkg/auth/http.go (0.0%)</option>
				
				<option value="file38">github.com/enseadaio/enseada/pkg/http/boot.go (0.0%)</option>
				
				<option value="file39">github.com/enseadaio/enseada/pkg/http/echo.go (0.0%)</option>
				
				<option value="file40">github.com/enseadaio/enseada/pkg/http/health.go (0.0%)</option>
				
				<option value="file41">github.com/enseadaio/enseada/pkg/http/renderer.go (0.0%)</option>
				
				<option value="file42">github.com/enseadaio/enseada/pkg/http/ui.go (0.0%)</option>
				
				<option value="file43">github.com/enseadaio/enseada/pkg/log/adapters/zap.go (16.1%)</option>
				
				<option value="file44">github.com/enseadaio/enseada/pkg/maven/boot.go (0.0%)</option>
				
				<option value="file45">github.com/enseadaio/enseada/pkg/maven/http.go (0.0%)</option>
				
				<option value="file46">github.com/enseadaio/enseada/rpc/auth/v1beta1/acl_api.pb.go (10.0%)</option>
				
				<option value="file47">github.com/enseadaio/enseada/rpc/auth/v1beta1/acl_api.twirp.go (0.0%)</option>
				
				<option value="file48">github.com/enseadaio/enseada/rpc/auth/v1beta1/acl_rule.pb.go (10.5%)</option>
				
				<option value="file49">github.com/enseadaio/enseada/rpc/auth/v1beta1/o_auth_client.pb.go (6.5%)</option>
				
				<option value="file50">github.com/enseadaio/enseada/rpc/auth/v1beta1/o_auth_clients_api.pb.go (9.1%)</option>
				
				<option value="file51">github.com/enseadaio/enseada/rpc/auth/v1beta1/o_auth_clients_api.twirp.go (0.0%)</option>
				
				<option value="file52">github.com/enseadaio/enseada/rpc/auth/v1beta1/user.pb.go (15.4%)</option>
				
				<option value="file53">github.com/enseadaio/enseada/rpc/auth/v1beta1/users_api.pb.go (9.3%)</option>
				
				<option value="file54">github.com/enseadaio/enseada/rpc/auth/v1beta1/users_api.twirp.go (0.0%)</option>
				
				<option value="file55">github.com/enseadaio/enseada/rpc/maven/v1beta1/maven_api.pb.go (9.3%)</option>
				
				<option value="file56">github.com/enseadaio/enseada/rpc/maven/v1beta1/maven_api.twirp.go (0.0%)</option>
				
				<option value="file57">github.com/enseadaio/enseada/rpc/maven/v1beta1/repo.pb.go (10.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package boot

import (
        "context"
        "fmt"

        "github.com/enseadaio/enseada/pkg/auth"
        "github.com/enseadaio/enseada/pkg/http"
        "github.com/enseadaio/enseada/pkg/log"
        "github.com/enseadaio/enseada/pkg/maven"
        "github.com/spf13/viper"
        goauth "golang.org/x/oauth2"
)

type StartFunc func(ctx context.Context) error
type StopFunc func(ctx context.Context) error

func Boot(ctx context.Context, logger log.Logger, conf *viper.Viper) (StartFunc, StopFunc, error) <span class="cov0" title="0">{
        skb := []byte(conf.GetString("secret.key.base"))
        ph := conf.GetString("public.host")
        sec := conf.GetString("default.oauth.client.secret")
        oc := &amp;goauth.Config{
                ClientID:     "enseada",
                ClientSecret: sec,
                Endpoint: goauth.Endpoint{
                        AuthURL:   ph + "/oauth/authorize",
                        TokenURL:  ph + "/oauth/token",
                        AuthStyle: goauth.AuthStyleAutoDetect,
                },
                RedirectURL: ph + "/ui/callback",
                Scopes:      []string{"openid", "profile"},
        }

        data, err := dbClient(ctx, conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">storage, err := storageBackend(conf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">echo, err := http.Boot(ctx, logger.Child("echo"), oc, skb)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">a, err := auth.Boot(ctx, echo, data, logger.Child("auth"), skb, ph, sec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">if err := maven.Boot(ctx, logger.Child("maven2"), echo, data, storage, a.Enforcer, a.Store, a.Provider); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return func(ctx context.Context) error </span><span class="cov0" title="0">{
                        if err := a.Watcher.Start(ctx); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">port := conf.GetString("port")
                        sslVar := conf.GetString("ssl")
                        ssl := sslVar != "" &amp;&amp; sslVar != "false" &amp;&amp; sslVar != "no"

                        address := fmt.Sprintf(":%s", port)
                        if ssl </span><span class="cov0" title="0">{
                                cert := conf.GetString("ssl.cert.path")
                                key := conf.GetString("ssl.key.path")
                                return echo.StartTLS(address, cert, key)
                        }</span> else<span class="cov0" title="0"> {
                                return echo.Start(address)
                        }</span>

                }, func(ctx context.Context) error <span class="cov0" title="0">{
                        echo.Logger.Info("Shutting down server...")
                        return echo.Shutdown(ctx)
                }</span>,
                nil
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package boot

import (
        "context"

        "github.com/go-kivik/couchdb"

        "github.com/go-kivik/kivik"
        "github.com/spf13/viper"
)

func dbClient(ctx context.Context, conf *viper.Viper) (*kivik.Client, error) <span class="cov0" title="0">{
        url := conf.GetString("couchdb.url")
        user := conf.GetString("couchdb.user")
        pwd := conf.GetString("couchdb.password")

        client, err := kivik.New("couch", url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = client.Authenticate(ctx, couchdb.BasicAuth(user, pwd))
        return client, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package boot

import (
        "fmt"

        "github.com/chartmuseum/storage"
        "github.com/spf13/viper"
)

func storageBackend(conf *viper.Viper) (storage.Backend, error) <span class="cov0" title="0">{
        provider := conf.GetString("storage.provider")
        storageDir := conf.GetString("storage.dir")

        switch provider </span>{
        //case "s3":
        //        return storage.NewAmazonS3Backend()
        case "local":<span class="cov0" title="0">
                return storage.NewLocalFilesystemBackend(storageDir), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported storage provider: %s", provider)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package get

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os"
        "time"

        mavenv1beta1 "github.com/enseadaio/enseada/rpc/maven/v1beta1"
        "github.com/jedib0t/go-pretty/table"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
        "github.com/twitchtv/twirp"
)

var getMvnRepo = &amp;cobra.Command{
        Use:     "mavenrepository [name]",
        Short:   "Get a Maven repository",
        Aliases: []string{"mvnrepo", "mavenrepositories", "mvnrepos"},
        Args:    cobra.MaximumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                url := viper.GetString("url")
                client := mavenv1beta1.NewMavenAPIProtobufClient(url, &amp;http.Client{})
                ctx, cancel := context.WithTimeout(context.Background(), time.Second*15)
                defer cancel()

                if len(args) == 1 </span><span class="cov0" title="0">{
                        if err := getRepo(ctx, client, args[0]); err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := listRepos(ctx, client); err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                os.Exit(1)
                        }</span>
                }
        },
}

func getRepo(ctx context.Context, client mavenv1beta1.MavenAPI, id string) error <span class="cov0" title="0">{
        res, err := client.GetRepo(ctx, &amp;mavenv1beta1.GetRepoRequest{
                Id: id,
        })

        if err != nil </span><span class="cov0" title="0">{
                twerr := err.(twirp.Error)
                return errors.New(twerr.Msg())
        }</span>

        <span class="cov0" title="0">printRepos(res.Repo)
        return nil</span>
}

func listRepos(ctx context.Context, client mavenv1beta1.MavenAPI) error <span class="cov0" title="0">{
        res, err := client.ListRepos(ctx, &amp;mavenv1beta1.ListReposRequest{})
        if err != nil </span><span class="cov0" title="0">{
                twerr := err.(twirp.Error)
                return errors.New(twerr.Msg())
        }</span>

        <span class="cov0" title="0">printRepos(res.Repos...)
        return nil</span>
}

func printRepos(repos ...*mavenv1beta1.Repo) <span class="cov0" title="0">{
        t := table.NewWriter()
        t.SetOutputMirror(os.Stdout)
        t.AppendHeader(table.Row{"Name", "Group Username", "Artifact Username"})
        for _, repo := range repos </span><span class="cov0" title="0">{
                t.AppendRow(table.Row{repo.GetId(), repo.GetGroupId(), repo.GetArtifactId()})
        }</span>
        <span class="cov0" title="0">t.Render()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package get

import (
        "github.com/spf13/cobra"
)

var RootCmd = &amp;cobra.Command{
        Use:   "get [resource]",
        Short: "Get a resource",
}

func init() <span class="cov10" title="2">{
        RootCmd.AddCommand(getMvnRepo)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "errors"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/ory/fosite"
        "golang.org/x/crypto/bcrypt"
)

type OAuthClient struct {
        ID            string     `json:"_id,omitempty"`
        Rev           string     `json:"_rev,omitempty"`
        Kind          couch.Kind `json:"kind"`
        HashedSecret  []byte     `json:"hashed_secret,omitempty"`
        RedirectURIs  []string   `json:"redirect_uris"`
        GrantTypes    []string   `json:"grant_types"`
        ResponseTypes []string   `json:"response_types"`
        Scopes        []string   `json:"scopes"`
        Audiences     []string   `json:"audiences"`
        Public        bool       `json:"public"`
}

type OAuthClientOptions struct {
        RedirectURIs  []string
        GrantTypes    []string
        ResponseTypes []string
        Scopes        []string
        Audiences     []string
        Public        bool
}

func NewOAuthClient(id string, secret string, opts ...OAuthClientOption) (*OAuthClient, error) <span class="cov10" title="5">{
        if id == "" </span><span class="cov1" title="1">{
                return nil, errors.New("client Username cannot be empty")
        }</span>

        <span class="cov8" title="4">options := &amp;OAuthClientOptions{
                RedirectURIs:  []string{},
                GrantTypes:    []string{},
                ResponseTypes: []string{},
                Scopes:        []string{},
                Audiences:     []string{},
                Public:        false,
        }

        for _, opt := range opts </span><span class="cov1" title="1">{
                opt(options)
        }</span>

        <span class="cov8" title="4">if !options.Public &amp;&amp; secret == "" </span><span class="cov1" title="1">{
                return nil, errors.New("client secret cannot be empty for non-public clients")
        }</span>

        <span class="cov7" title="3">var hashed []byte
        if !options.Public </span><span class="cov4" title="2">{
                h, err := bcrypt.GenerateFromPassword([]byte(secret), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="2">hashed = h</span>
        }

        <span class="cov7" title="3">if len(options.GrantTypes) == 0 </span><span class="cov7" title="3">{
                options.GrantTypes = fosite.Arguments{"authorization_code"}
        }</span>

        <span class="cov7" title="3">if len(options.ResponseTypes) == 0 </span><span class="cov7" title="3">{
                options.ResponseTypes = fosite.Arguments{"code"}
        }</span>

        <span class="cov7" title="3">return &amp;OAuthClient{
                ID:            id,
                Kind:          couch.KindOAuthClient,
                HashedSecret:  hashed,
                RedirectURIs:  options.RedirectURIs,
                GrantTypes:    options.GrantTypes,
                ResponseTypes: options.ResponseTypes,
                Scopes:        options.Scopes,
                Audiences:     options.Audiences,
                Public:        options.Public,
        }, nil</span>
}

// GetID returns the client Username.
func (c *OAuthClient) GetID() string <span class="cov1" title="1">{
        return c.ID
}</span>

func (c *OAuthClient) GetRev() string <span class="cov0" title="0">{
        return c.Rev
}</span>

func (c *OAuthClient) SetRev(rev string) <span class="cov0" title="0">{
        c.Rev = rev
}</span>

// GetHashedSecret returns the hashed secret as it is stored in the store.
func (c *OAuthClient) GetHashedSecret() []byte <span class="cov4" title="2">{
        return c.HashedSecret
}</span>

// GetRedirectURIs returns the client's allowed redirect URIs.
func (c *OAuthClient) GetRedirectURIs() []string <span class="cov1" title="1">{
        return c.RedirectURIs
}</span>

// GetGrantTypes returns the client's allowed grant types.
func (c *OAuthClient) GetGrantTypes() fosite.Arguments <span class="cov1" title="1">{
        return c.GrantTypes
}</span>

// GetResponseTypes returns the client's allowed response types.
func (c *OAuthClient) GetResponseTypes() fosite.Arguments <span class="cov1" title="1">{
        return c.ResponseTypes
}</span>

// GetScopes returns the scopes this client is allowed to request.
func (c *OAuthClient) GetScopes() fosite.Arguments <span class="cov1" title="1">{
        return c.Scopes
}</span>

// IsPublic returns true, if this client is marked as public.
func (c *OAuthClient) IsPublic() bool <span class="cov1" title="1">{
        return c.Public
}</span>

// GetAudience returns the allowed audience(s) for this client.
func (c *OAuthClient) GetAudience() fosite.Arguments <span class="cov1" title="1">{
        return c.Audiences
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

type OAuthClientOption func(opts *OAuthClientOptions)

func OAuthRedirectURIs(uris ...string) OAuthClientOption <span class="cov0" title="0">{
        return func(opts *OAuthClientOptions) </span><span class="cov0" title="0">{
                opts.RedirectURIs = uris
        }</span>
}

func OAuthGrantTypes(types ...string) OAuthClientOption <span class="cov0" title="0">{
        return func(opts *OAuthClientOptions) </span><span class="cov0" title="0">{
                opts.GrantTypes = types
        }</span>
}

func OAuthResponseTypes(types ...string) OAuthClientOption <span class="cov0" title="0">{
        return func(opts *OAuthClientOptions) </span><span class="cov0" title="0">{
                opts.ResponseTypes = types
        }</span>
}

func OAuthScopes(scopes ...string) OAuthClientOption <span class="cov0" title="0">{
        return func(opts *OAuthClientOptions) </span><span class="cov0" title="0">{
                opts.Scopes = scopes
        }</span>
}

func OAuthAudiences(audiences ...string) OAuthClientOption <span class="cov0" title="0">{
        return func(opts *OAuthClientOptions) </span><span class="cov0" title="0">{
                opts.Audiences = audiences
        }</span>
}

func OAuthPublic(public bool) OAuthClientOption <span class="cov8" title="1">{
        return func(opts *OAuthClientOptions) </span><span class="cov8" title="1">{
                opts.Public = public
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "context"
        "errors"
        "fmt"

        "github.com/enseadaio/enseada/pkg/log"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/go-kivik/kivik"
        "github.com/ory/fosite"
)

type OAuthClientStore struct {
        Logger log.Logger
        Data   *kivik.Client
}

func NewOAuthClientStore(data *kivik.Client, logger log.Logger) *OAuthClientStore <span class="cov8" title="1">{
        return &amp;OAuthClientStore{Logger: logger, Data: data}
}</span>

func (c *OAuthClientStore) GetClient(ctx context.Context, id string) (fosite.Client, error) <span class="cov8" title="1">{
        db := c.Data.DB(ctx, couch.OAuthDB)
        row := db.Get(ctx, id)

        var client OAuthClient
        if err := row.ScanDoc(&amp;client); err != nil </span><span class="cov0" title="0">{
                if kivik.StatusCode(err) == kivik.StatusNotFound </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">c.Logger.Error(err)
                return nil, err</span>
        }

        <span class="cov8" title="1">return &amp;client, nil</span>
}

func (c *OAuthClientStore) ListClients(ctx context.Context, selector couch.Query) ([]fosite.Client, error) <span class="cov0" title="0">{
        db := c.Data.DB(ctx, couch.OAuthDB)
        s := couch.Query{
                "kind": couch.KindOAuthClient,
        }
        if len(selector) &gt; 0 </span><span class="cov0" title="0">{
                delete(selector, "kind")
                for k, v := range selector </span><span class="cov0" title="0">{
                        s[k] = v
                }</span>

        }

        <span class="cov0" title="0">rows, err := db.Find(ctx, couch.Query{
                "selector": s,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var clients []fosite.Client
        for rows.Next() </span><span class="cov0" title="0">{
                client := new(OAuthClient)
                if err := rows.ScanDoc(client); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">clients = append(clients, client)</span>
        }

        <span class="cov0" title="0">return clients, nil</span>
}

func (c *OAuthClientStore) DeleteClient(ctx context.Context, id string) (fosite.Client, error) <span class="cov0" title="0">{
        db := c.Data.DB(ctx, couch.OAuthDB)
        row := db.Get(ctx, id)
        cc := new(OAuthClient)
        if err := row.ScanDoc(cc); err != nil </span><span class="cov0" title="0">{
                if kivik.StatusCode(err) == kivik.StatusNotFound </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">rev, err := db.Delete(ctx, cc.ID, cc.Rev)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cc.Rev = rev
        return cc, nil</span>
}

func (c *OAuthClientStore) SaveClient(ctx context.Context, client fosite.Client) error <span class="cov0" title="0">{
        cl, ok := client.(couch.Storable)
        if !ok </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("client %s does not implement couch.Storable", client.GetID()))
        }</span>

        <span class="cov0" title="0">db := c.Data.DB(ctx, couch.OAuthDB)
        rev, err := db.Put(ctx, cl.GetID(), client)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cl.SetRev(rev)
        return nil</span>
}

func (c *OAuthClientStore) InitDefaultClients(ctx context.Context, ph string, secret string) error <span class="cov0" title="0">{
        db := c.Data.DB(ctx, couch.OAuthDB)

        client, err := NewOAuthClient("enseada", secret,
                OAuthGrantTypes("authorization_code", "implicit", "refresh_token", "password", "client_credentials"),
                OAuthResponseTypes("code", "id_token", "token id_token", "code id_token", "code token", "code token id_token"),
                OAuthScopes("*"),
                OAuthRedirectURIs(ph+"/ui/callback"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = c.initClient(ctx, db, client)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cli, err := NewOAuthClient("enseada-cli", "",
                OAuthGrantTypes("refresh_token", "password", "client_credentials"),
                OAuthResponseTypes("code", "id_token", "token id_token", "code id_token", "code token", "code token id_token"),
                OAuthScopes("*"),
                OAuthPublic(true),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = c.initClient(ctx, db, cli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.Logger.Infof("created default OAuthProvider client. client_id: %s client_secret: %s", "enseada", secret)
        return nil</span>
}

func (c *OAuthClientStore) initClient(ctx context.Context, db *kivik.DB, cc *OAuthClient) error <span class="cov0" title="0">{
        _, rev, err := db.GetMeta(ctx, cc.GetID())
        if err != nil &amp;&amp; kivik.StatusCode(err) != kivik.StatusNotFound </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cc.Rev = rev
        return c.SaveClient(ctx, cc)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "net/url"
        "time"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/ory/fosite"
        "github.com/ory/fosite/handler/openid"
)

type OAuthRequestWrapper struct {
        ID      string        `json:"_id,omitempty"`
        Rev     string        `json:"_rev,omitempty"`
        Kind    couch.Kind    `json:"kind"`
        Req     *OAuthRequest `json:"req"`
        Revoked bool          `json:"revoked,omitempty"`
        Sig     string        `json:"sig,omitempty"`
}

type OAuthRequest struct {
        ID                string                 `json:"id"`
        RequestedAt       time.Time              `json:"requested_at"`
        Client            *OAuthClient           `json:"client"`
        RequestedScopes   fosite.Arguments       `json:"scopes"`
        GrantedScopes     fosite.Arguments       `json:"granted_scopes"`
        Form              url.Values             `json:"form"`
        Session           *openid.DefaultSession `json:"session"`
        RequestedAudience fosite.Arguments       `json:"requested_audience"`
        GrantedAudience   fosite.Arguments       `json:"granted_audience"`
}

func (r *OAuthRequest) SetID(id string) <span class="cov0" title="0">{
        r.ID = id
}</span>

func (r *OAuthRequest) GetID() string <span class="cov0" title="0">{
        return r.ID
}</span>

func (r *OAuthRequest) GetRequestedAt() time.Time <span class="cov0" title="0">{
        return r.RequestedAt
}</span>

func (r *OAuthRequest) GetClient() fosite.Client <span class="cov0" title="0">{
        return r.Client
}</span>

func (r *OAuthRequest) GetRequestedScopes() fosite.Arguments <span class="cov0" title="0">{
        return r.RequestedScopes
}</span>

func (r *OAuthRequest) GetRequestedAudience() fosite.Arguments <span class="cov0" title="0">{
        return r.RequestedAudience
}</span>

func (r *OAuthRequest) SetRequestedScopes(scopes fosite.Arguments) <span class="cov0" title="0">{
        r.RequestedScopes = scopes
}</span>

func (r *OAuthRequest) SetRequestedAudience(audience fosite.Arguments) <span class="cov0" title="0">{
        r.RequestedAudience = audience
}</span>

func (r *OAuthRequest) AppendRequestedScope(scope string) <span class="cov0" title="0">{
        for _, has := range r.RequestedScopes </span><span class="cov0" title="0">{
                if scope == has </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">r.RequestedScopes = append(r.RequestedScopes, scope)</span>
}

func (r *OAuthRequest) GetGrantedScopes() fosite.Arguments <span class="cov0" title="0">{
        return r.GrantedScopes
}</span>

func (r *OAuthRequest) GetGrantedAudience() fosite.Arguments <span class="cov0" title="0">{
        return r.GrantedAudience
}</span>

func (r *OAuthRequest) GrantScope(scope string) <span class="cov0" title="0">{
        for _, has := range r.GrantedScopes </span><span class="cov0" title="0">{
                if scope == has </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">r.GrantedScopes = append(r.GrantedScopes, scope)</span>
}

func (r *OAuthRequest) GrantAudience(audience string) <span class="cov0" title="0">{
        for _, has := range r.GrantedAudience </span><span class="cov0" title="0">{
                if audience == has </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">r.GrantedAudience = append(r.GrantedAudience, audience)</span>
}

func (r *OAuthRequest) GetSession() fosite.Session <span class="cov0" title="0">{
        return r.Session
}</span>

func (r *OAuthRequest) SetSession(session fosite.Session) <span class="cov0" title="0">{
        r.Session = session.(*openid.DefaultSession)
}</span>

func (r *OAuthRequest) GetRequestForm() url.Values <span class="cov0" title="0">{
        return r.Form
}</span>

func (r *OAuthRequest) Merge(request fosite.Requester) <span class="cov0" title="0">{
        r.RequestedScopes = request.GetRequestedScopes()
        r.GrantedScopes = request.GetGrantedScopes()
        r.RequestedAudience = request.GetRequestedAudience()
        r.GrantedAudience = request.GetGrantedAudience()
        r.RequestedAt = request.GetRequestedAt()
        r.Client = request.GetClient().(*OAuthClient)
        r.SetSession(request.GetSession())
        r.Form = request.GetRequestForm()
}</span>

func (r *OAuthRequest) Sanitize(allowedParameters []string) fosite.Requester <span class="cov0" title="0">{
        return r
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "context"
        "errors"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
        "github.com/ory/fosite"
)

type OAuthRequestStore struct {
        data   *kivik.Client
        logger log.Logger
}

func NewOAuthRequestStore(data *kivik.Client, logger log.Logger) *OAuthRequestStore <span class="cov0" title="0">{
        return &amp;OAuthRequestStore{data: data, logger: logger}
}</span>

func (t *OAuthRequestStore) CreateAuthorizeCodeSession(ctx context.Context, signature string, request fosite.Requester) error <span class="cov0" title="0">{
        req := &amp;OAuthRequest{}
        req.Merge(request)
        return t.store(ctx, &amp;OAuthRequestWrapper{
                Kind: couch.KindOAuthAuthorizeCode,
                Sig:  signature,
                Req:  req,
        })
}</span>

func (t *OAuthRequestStore) GetAuthorizeCodeSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) <span class="cov0" title="0">{
        token, err := t.findOne(ctx, couch.Query{
                "selector": couch.Query{
                        "kind": couch.KindOAuthAuthorizeCode,
                        "sig":  signature,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if token.Revoked </span><span class="cov0" title="0">{
                return token.Req, fosite.ErrInvalidatedAuthorizeCode
        }</span>

        <span class="cov0" title="0">session = token.Req.GetSession()
        return token.Req, nil</span>
}

func (t *OAuthRequestStore) InvalidateAuthorizeCodeSession(ctx context.Context, signature string) error <span class="cov0" title="0">{
        token, err := t.findOne(ctx, couch.Query{
                "selector": couch.Query{
                        "kind": couch.KindOAuthAuthorizeCode,
                        "sig":  signature,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return t.delete(ctx, token.ID, token.Rev)</span>
}

func (t *OAuthRequestStore) CreateAccessTokenSession(ctx context.Context, signature string, request fosite.Requester) error <span class="cov0" title="0">{
        req := &amp;OAuthRequest{}
        req.Merge(request)
        return t.store(ctx, &amp;OAuthRequestWrapper{
                Kind: couch.KindOAuthAccessToken,
                Sig:  signature,
                Req:  req,
        })
}</span>

func (t *OAuthRequestStore) GetAccessTokenSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) <span class="cov0" title="0">{
        token, err := t.findOne(ctx, couch.Query{
                "selector": couch.Query{
                        "kind": couch.KindOAuthAccessToken,
                        "sig":  signature,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if token.Revoked </span><span class="cov0" title="0">{
                return nil, fosite.ErrInactiveToken
        }</span>

        <span class="cov0" title="0">session = token.Req.GetSession()
        return token.Req, nil</span>
}

func (t *OAuthRequestStore) DeleteAccessTokenSession(ctx context.Context, signature string) error <span class="cov0" title="0">{
        token, err := t.findOne(ctx, couch.Query{
                "selector": couch.Query{
                        "kind": couch.KindOAuthAccessToken,
                        "sig":  signature,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return t.delete(ctx, token.ID, token.Rev)</span>
}

func (t *OAuthRequestStore) CreateRefreshTokenSession(ctx context.Context, signature string, request fosite.Requester) error <span class="cov0" title="0">{
        req := &amp;OAuthRequest{}
        req.Merge(request)
        return t.store(ctx, &amp;OAuthRequestWrapper{
                Kind: couch.KindOAuthRefreshToken,
                Sig:  signature,
                Req:  req,
        })
}</span>

func (t *OAuthRequestStore) GetRefreshTokenSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) <span class="cov0" title="0">{
        token, err := t.findOne(ctx, couch.Query{
                "selector": couch.Query{
                        "kind": couch.KindOAuthRefreshToken,
                        "sig":  signature,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if token.Revoked </span><span class="cov0" title="0">{
                return nil, fosite.ErrInactiveToken
        }</span>

        <span class="cov0" title="0">session = token.Req.GetSession()
        return token.Req, nil</span>
}

func (t *OAuthRequestStore) DeleteRefreshTokenSession(ctx context.Context, signature string) error <span class="cov0" title="0">{
        token, err := t.findOne(ctx, couch.Query{
                "selector": couch.Query{
                        "kind": couch.KindOAuthRefreshToken,
                        "sig":  signature,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return t.delete(ctx, token.ID, token.Rev)</span>
}

func (t *OAuthRequestStore) RevokeAccessToken(ctx context.Context, requestID string) error <span class="cov0" title="0">{
        token, err := t.findOne(ctx, couch.Query{
                "selector": couch.Query{
                        "req.id": requestID,
                        "kind":   couch.KindOAuthAccessToken,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">token.Revoked = true
        return t.store(ctx, token)</span>
}

func (t *OAuthRequestStore) RevokeRefreshToken(ctx context.Context, requestID string) error <span class="cov0" title="0">{
        token, err := t.findOne(ctx, couch.Query{
                "selector": couch.Query{
                        "req.id": requestID,
                        "kind":   couch.KindOAuthRefreshToken,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">token.Revoked = true
        return t.store(ctx, token)</span>
}

func (t *OAuthRequestStore) store(ctx context.Context, token *OAuthRequestWrapper) error <span class="cov0" title="0">{
        db := t.data.DB(ctx, couch.OAuthDB)
        if token.ID != "" &amp;&amp; token.Rev == "" </span><span class="cov0" title="0">{
                _, rev, err := db.GetMeta(ctx, token.ID)
                if err != nil </span><span class="cov0" title="0">{
                        if kivik.StatusCode(err) != kivik.StatusNotFound </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">token.Rev = rev</span>
        }
        <span class="cov0" title="0">if token.ID == "" </span><span class="cov0" title="0">{
                id, rev, err := db.CreateDoc(ctx, token)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">token.ID = id
                token.Rev = rev
                return nil</span>
        } else<span class="cov0" title="0"> {
                rev, err := db.Put(ctx, token.ID, token)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">token.Rev = rev
                return nil</span>
        }
}

func (t *OAuthRequestStore) get(ctx context.Context, id string) (*OAuthRequestWrapper, error) <span class="cov0" title="0">{
        db := t.data.DB(ctx, couch.OAuthDB)
        row := db.Get(ctx, id)
        var token OAuthRequestWrapper
        if err := row.ScanDoc(&amp;token); err != nil </span><span class="cov0" title="0">{
                if kivik.StatusCode(err) == kivik.StatusNotFound </span><span class="cov0" title="0">{
                        return nil, fosite.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;token, nil</span>
}

func (t *OAuthRequestStore) find(ctx context.Context, query interface{}) ([]*OAuthRequestWrapper, error) <span class="cov0" title="0">{
        var tokens []*OAuthRequestWrapper

        db := t.data.DB(ctx, couch.OAuthDB)
        rows, err := db.Find(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return tokens, err
        }</span>

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var token OAuthRequestWrapper
                if err := rows.ScanDoc(&amp;token); err != nil </span><span class="cov0" title="0">{
                        return tokens, err
                }</span>
                <span class="cov0" title="0">tokens = append(tokens, &amp;token)</span>
        }

        <span class="cov0" title="0">if rows.Err() != nil </span><span class="cov0" title="0">{
                return tokens, rows.Err()
        }</span>

        <span class="cov0" title="0">return tokens, nil</span>
}

func (t *OAuthRequestStore) findOne(ctx context.Context, query interface{}) (*OAuthRequestWrapper, error) <span class="cov0" title="0">{
        tokens, err := t.find(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(tokens) == 0 </span><span class="cov0" title="0">{
                return nil, fosite.ErrNotFound
        }</span>

        <span class="cov0" title="0">if len(tokens) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("too many results")
        }</span>

        <span class="cov0" title="0">return tokens[0], nil</span>
}

func (t *OAuthRequestStore) delete(ctx context.Context, id string, rev string) error <span class="cov0" title="0">{
        db := t.data.DB(ctx, couch.OAuthDB)
        if rev == "" </span><span class="cov0" title="0">{
                _, r, err := db.GetMeta(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        if kivik.StatusCode(err) == kivik.StatusNotFound </span><span class="cov0" title="0">{
                                return fosite.ErrNotFound
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">rev = r</span>
        }

        <span class="cov0" title="0">_, err := db.Delete(ctx, id, rev)
        return err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "gopkg.in/square/go-jose.v2"
)

type OIDCClient struct {
        *OAuthClient
        JSONWebKeysURI                string              `json:"jwks_uri"`
        JSONWebKeys                   *jose.JSONWebKeySet `json:"jwks"`
        TokenEndpointAuthMethod       string              `json:"token_endpoint_auth_method"`
        RequestURIs                   []string            `json:"request_uris"`
        RequestObjectSigningAlgorithm string              `json:"request_object_signing_alg"`
}

func NewOIDCClient(id string, secret string, opts ...OIDCClientOption) (*OIDCClient, error) <span class="cov0" title="0">{
        options := &amp;OIDCClientOptions{
                OAuthClientOptions: []OAuthClientOption{},
                JwksURI:            "",
                Jwks:               nil,
                TokenAuthMethod:    "",
                RequestURIs:        nil,
                RequestAlgo:        "",
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(options)
        }</span>

        <span class="cov0" title="0">oc, err := NewOAuthClient(id, secret, options.OAuthClientOptions...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;OIDCClient{
                OAuthClient:                   oc,
                JSONWebKeysURI:                options.JwksURI,
                JSONWebKeys:                   options.Jwks,
                TokenEndpointAuthMethod:       options.TokenAuthMethod,
                RequestURIs:                   options.RequestURIs,
                RequestObjectSigningAlgorithm: options.RequestAlgo,
        }, nil</span>
}

// GetRequestURIs is an array of request_uri values that are pre-registered by the RP for use at the OP. Servers MAY
// cache the contents of the files referenced by these URIs and not retrieve them at the time they are used in a request.
// OPs can require that request_uri values used be pre-registered with the require_request_uri_registration
// discovery parameter.
func (c *OIDCClient) GetRequestURIs() []string <span class="cov0" title="0">{
        return c.RequestURIs
}</span>

// GetJSONWebKeys returns the JSON Web Key Set containing the public keys used by the client to authenticate.
func (c *OIDCClient) GetJSONWebKeys() *jose.JSONWebKeySet <span class="cov0" title="0">{
        return c.JSONWebKeys
}</span>

// GetJSONWebKeys returns the URL for lookup of JSON Web Key Set containing the
// public keys used by the client to authenticate.
func (c *OIDCClient) GetJSONWebKeysURI() string <span class="cov0" title="0">{
        return c.JSONWebKeysURI
}</span>

// JWS [JWS] alg algorithm [JWA] that MUST be used for signing OAuthRequestWrapper Objects sent to the OP.
// All OAuthRequestWrapper Objects from this OAuthClient MUST be rejected, if not signed with this algorithm.
func (c *OIDCClient) GetRequestObjectSigningAlgorithm() string <span class="cov0" title="0">{
        return c.RequestObjectSigningAlgorithm
}</span>

// Requested OAuthClient Authentication method for the Token Endpoint. The options are client_secret_post,
// client_secret_basic, client_secret_jwt, private_key_jwt, and none.
func (c *OIDCClient) GetTokenEndpointAuthMethod() string <span class="cov0" title="0">{
        return c.TokenEndpointAuthMethod
}</span>

// JWS [JWS] alg algorithm [JWA] that MUST be used for signing the JWT [JWT] used to authenticate the
// OAuthClient at the Token Endpoint for the private_key_jwt and client_secret_jwt authentication methods.
func (c *OIDCClient) GetTokenEndpointAuthSigningAlgorithm() string <span class="cov0" title="0">{
        return "RS256"
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "gopkg.in/square/go-jose.v2"
)

type OIDCClientOption func(opts *OIDCClientOptions)

type OIDCClientOptions struct {
        OAuthClientOptions []OAuthClientOption
        JwksURI            string
        Jwks               *jose.JSONWebKeySet
        TokenAuthMethod    string
        RequestURIs        []string
        RequestAlgo        string
}

func OIDCRedirectURIs(uris ...string) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.OAuthClientOptions = append(opts.OAuthClientOptions, OAuthRedirectURIs(uris...))
        }</span>
}

func OIDCGrantTypes(types ...string) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.OAuthClientOptions = append(opts.OAuthClientOptions, OAuthGrantTypes(types...))
        }</span>
}

func OIDCResponseTypes(types ...string) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.OAuthClientOptions = append(opts.OAuthClientOptions, OAuthResponseTypes(types...))
        }</span>
}

func OIDCScopes(scopes ...string) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.OAuthClientOptions = append(opts.OAuthClientOptions, OAuthScopes(scopes...))
        }</span>
}

func OIDCAudiences(audiences ...string) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.OAuthClientOptions = append(opts.OAuthClientOptions, OAuthAudiences(audiences...))
        }</span>
}

func OIDCPublic(public bool) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.OAuthClientOptions = append(opts.OAuthClientOptions, OAuthPublic(public))
        }</span>
}

func OIDCJSONWebKeysURI(uri string) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.JwksURI = uri
        }</span>
}

func OIDCJSONWebKeys(jwks *jose.JSONWebKeySet) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.Jwks = jwks
        }</span>
}

func OIDCTokenEndpointAuthMethod(method string) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.TokenAuthMethod = method
        }</span>
}

func OIDCRequestURIs(uris ...string) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.RequestURIs = uris
        }</span>
}

func OIDCRequestObjectSigningAlgorithm(algorithm string) OIDCClientOption <span class="cov0" title="0">{
        return func(opts *OIDCClientOptions) </span><span class="cov0" title="0">{
                opts.RequestAlgo = algorithm
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "context"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
        "github.com/ory/fosite"
        "github.com/ory/fosite/handler/openid"
)

type OIDCSessionStore struct {
        data   *kivik.Client
        logger log.Logger
}

func NewOIDCSessionStore(data *kivik.Client, logger log.Logger) *OIDCSessionStore <span class="cov0" title="0">{
        return &amp;OIDCSessionStore{data: data, logger: logger}
}</span>

func (s *OIDCSessionStore) CreateOpenIDConnectSession(ctx context.Context, authorizeCode string, requester fosite.Requester) error <span class="cov0" title="0">{
        req := &amp;OAuthRequest{}
        req.Merge(requester)
        db := s.data.DB(ctx, couch.OAuthDB)
        _, _, err := db.CreateDoc(ctx, &amp;OIDCSession{
                Kind:     couch.KindOpenIDSession,
                AuthCode: authorizeCode,
                Req:      req,
        })
        return err
}</span>

func (s *OIDCSessionStore) GetOpenIDConnectSession(ctx context.Context, authorizeCode string, requester fosite.Requester) (fosite.Requester, error) <span class="cov0" title="0">{
        db := s.data.DB(ctx, couch.OAuthDB)
        rows, err := db.Find(ctx, couch.Query{
                "selector": couch.Query{
                        "kind":      couch.KindOpenIDSession,
                        "auth_code": authorizeCode,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var session OIDCSession
        if rows.Next() </span><span class="cov0" title="0">{
                if err := rows.ScanDoc(&amp;session); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">requester.SetSession(session.Req.GetSession())
                return session.Req, nil</span>
        }

        <span class="cov0" title="0">return nil, openid.ErrNoSessionFound</span>
}

func (s *OIDCSessionStore) DeleteOpenIDConnectSession(ctx context.Context, authorizeCode string) error <span class="cov0" title="0">{
        db := s.data.DB(ctx, couch.OAuthDB)
        rows, err := db.Find(ctx, couch.Query{
                "selector": couch.Query{
                        "kind":      couch.KindOpenIDSession,
                        "auth_code": authorizeCode,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var session OIDCSession
        if rows.Next() </span><span class="cov0" title="0">{
                if err := rows.ScanDoc(&amp;session); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_, err = db.Delete(ctx, session.ID, session.Rev)
                return err</span>
        }
        <span class="cov0" title="0">return openid.ErrNoSessionFound</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "context"
        "errors"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
        "github.com/ory/fosite"
)

type PKCERequestStore struct {
        data   *kivik.Client
        logger log.Logger
}

func NewPKCERequestStore(data *kivik.Client, logger log.Logger) *PKCERequestStore <span class="cov0" title="0">{
        return &amp;PKCERequestStore{data: data, logger: logger}
}</span>

func (r *PKCERequestStore) CreatePKCERequestSession(ctx context.Context, signature string, requester fosite.Requester) error <span class="cov0" title="0">{
        req := &amp;OAuthRequest{}
        req.Merge(requester)
        db := r.data.DB(ctx, couch.OAuthDB)
        _, _, err := db.CreateDoc(ctx, &amp;OAuthRequestWrapper{
                Kind: couch.KindPKCERequest,
                Sig:  signature,
                Req:  req,
        })
        return err
}</span>

func (r *PKCERequestStore) GetPKCERequestSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) <span class="cov0" title="0">{
        db := r.data.DB(ctx, couch.OAuthDB)
        rows, err := db.Find(ctx, couch.Query{
                "selector": couch.Query{
                        "kind": couch.KindPKCERequest,
                        "sig":  signature,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var request OAuthRequestWrapper
        if rows.Next() </span><span class="cov0" title="0">{
                if err := rows.ScanDoc(&amp;request); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">session = request.Req.GetSession()
                return request.Req, nil</span>
        }

        <span class="cov0" title="0">return nil, errors.New("pkce request not found")</span>
}

func (r *PKCERequestStore) DeletePKCERequestSession(ctx context.Context, signature string) error <span class="cov0" title="0">{
        db := r.data.DB(ctx, couch.OAuthDB)
        rows, err := db.Find(ctx, couch.Query{
                "selector": couch.Query{
                        "kind": couch.KindPKCERequest,
                        "sig":  signature,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var request OAuthRequestWrapper
        if rows.Next() </span><span class="cov0" title="0">{
                if err := rows.ScanDoc(&amp;request); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_, err = db.Delete(ctx, request.ID, request.Rev)
                return err</span>
        }
        <span class="cov0" title="0">return errors.New("pkce request not found")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "time"

        "github.com/labstack/echo"
        "github.com/ory/fosite"
        "github.com/ory/fosite/handler/openid"
        "github.com/ory/fosite/token/jwt"
)

func NewSession(u *User, audiences ...string) fosite.Session <span class="cov0" title="0">{
        if len(audiences) == 0 </span><span class="cov0" title="0">{
                audiences = []string{"enseada"}
        }</span>

        <span class="cov0" title="0">if u == nil </span><span class="cov0" title="0">{
                return &amp;openid.DefaultSession{
                        Claims: &amp;jwt.IDTokenClaims{
                                Issuer:      "enseada",
                                Subject:     "",
                                Audience:    audiences,
                                Nonce:       "",
                                ExpiresAt:   time.Now().Add(time.Hour * 6),
                                IssuedAt:    time.Now(),
                                RequestedAt: time.Now(),
                                AuthTime:    time.Now(),
                        },
                        Username: "",
                        Subject:  "",
                }
        }</span>

        <span class="cov0" title="0">return &amp;openid.DefaultSession{
                Claims: &amp;jwt.IDTokenClaims{
                        Issuer:      "enseada",
                        Subject:     u.Username,
                        Audience:    audiences,
                        Nonce:       "",
                        ExpiresAt:   time.Now().Add(time.Hour * 6),
                        IssuedAt:    time.Now(),
                        RequestedAt: time.Now(),
                        AuthTime:    time.Now(),
                        Extra: echo.Map{
                                "username": u.Username,
                        },
                },
                Username: u.Username,
                Subject:  u.Username,
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
)

type Store struct {
        data   *kivik.Client
        logger log.Logger
        *OAuthClientStore
        *OAuthRequestStore
        *OIDCSessionStore
        *PKCERequestStore
        *UserStore
}

func NewStore(data *kivik.Client, logger log.Logger, cs *OAuthClientStore, rs *OAuthRequestStore, os *OIDCSessionStore, ps *PKCERequestStore, us *UserStore) *Store <span class="cov0" title="0">{
        return &amp;Store{
                data:              data,
                logger:            logger,
                OAuthClientStore:  cs,
                OAuthRequestStore: rs,
                OIDCSessionStore:  os,
                PKCERequestStore:  ps,
                UserStore:         us,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

type User struct {
        Username       string `json:"_id"`
        Rev            string `json:"_rev,omitempty"`
        Password       string `json:"-"`
        HashedPassword []byte `json:"hashed_password"`
}

func RootUser(pwd string) *User <span class="cov0" title="0">{
        return &amp;User{
                Username: "root",
                Password: pwd,
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "context"
        "errors"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
        "github.com/ory/fosite"
        "golang.org/x/crypto/bcrypt"
)

type UserStore struct {
        data   *kivik.Client
        logger log.Logger
}

func NewUserStore(data *kivik.Client, logger log.Logger) *UserStore <span class="cov0" title="0">{
        return &amp;UserStore{
                data:   data,
                logger: logger,
        }
}</span>

func (s *UserStore) Authenticate(ctx context.Context, username string, password string) error <span class="cov0" title="0">{
        u, err := s.GetUser(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                if kivik.StatusCode(err) == kivik.StatusNotFound </span><span class="cov0" title="0">{
                        return fosite.ErrNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return bcrypt.CompareHashAndPassword(u.HashedPassword, []byte(password))</span>
}

func (s *UserStore) SaveUser(ctx context.Context, u *User) error <span class="cov0" title="0">{
        db := s.data.DB(ctx, couch.UsersDB)
        if u.HashedPassword == nil </span><span class="cov0" title="0">{
                err := hashPassword(u)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">id, rev, err := db.CreateDoc(ctx, u)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u.Username = id
        u.Rev = rev
        return nil</span>
}

func (s *UserStore) UpdateUser(ctx context.Context, u *User) error <span class="cov0" title="0">{
        db := s.data.DB(ctx, couch.UsersDB)

        if u.Password != "" </span><span class="cov0" title="0">{
                err := hashPassword(u)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if u.Rev == "" </span><span class="cov0" title="0">{
                _, rev, err := db.GetMeta(ctx, u.Username)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">u.Rev = rev</span>
        }

        <span class="cov0" title="0">rev, err := db.Put(ctx, u.Username, u)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u.Rev = rev
        return nil</span>
}

func (s *UserStore) ListUsers(ctx context.Context) ([]*User, error) <span class="cov0" title="0">{
        db := s.data.DB(ctx, couch.UsersDB)
        rows, err := db.AllDocs(ctx, kivik.Options{
                "include_docs": true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var users []*User
        for rows.Next() </span><span class="cov0" title="0">{
                user := new(User)
                if err := rows.ScanDoc(user); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}

func (s *UserStore) GetUser(ctx context.Context, username string) (*User, error) <span class="cov0" title="0">{
        db := s.data.DB(ctx, couch.UsersDB)
        row := db.Get(ctx, username)
        var user User
        if err := row.ScanDoc(&amp;user); err != nil </span><span class="cov0" title="0">{
                if kivik.StatusCode(err) == kivik.StatusNotFound </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if row.Err != nil </span><span class="cov0" title="0">{
                return nil, row.Err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (s *UserStore) DeleteUser(ctx context.Context, u *User) error <span class="cov0" title="0">{
        db := s.data.DB(ctx, couch.UsersDB)

        if u.Rev == "" </span><span class="cov0" title="0">{
                _, rev, err := db.GetMeta(ctx, u.Username)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">u.Rev = rev</span>
        }

        <span class="cov0" title="0">rev, err := db.Delete(ctx, u.Username, u.Rev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u.Rev = rev
        return nil</span>
}

func hashPassword(u *User) error <span class="cov0" title="0">{
        if u.Password == "" </span><span class="cov0" title="0">{
                return errors.New("user password cannot be blank")
        }</span>

        <span class="cov0" title="0">h, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u.HashedPassword = h
        u.Password = ""
        return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package authv1beta1api

import (
        "context"

        "github.com/enseadaio/enseada/pkg/log"

        "github.com/enseadaio/enseada/internal/ctxutils"

        "github.com/casbin/casbin/v2"
        "github.com/enseadaio/enseada/internal/guid"
        "github.com/enseadaio/enseada/internal/scope"
        authv1beta1 "github.com/enseadaio/enseada/rpc/auth/v1beta1"
        "github.com/twitchtv/twirp"
)

type AclAPI struct {
        Logger   log.Logger
        Enforcer *casbin.Enforcer
}

func NewAclAPI(logger log.Logger, enforcer *casbin.Enforcer) *AclAPI <span class="cov0" title="0">{
        return &amp;AclAPI{Logger: logger, Enforcer: enforcer}
}</span>

func (s *AclAPI) ListRules(ctx context.Context, req *authv1beta1.ListRulesRequest) (*authv1beta1.ListRulesResponse, error) <span class="cov0" title="0">{
        scopes, ok := ctxutils.Scopes(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">if !scopes.Has(scope.ACLRuleRead) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">policy := s.Enforcer.GetPolicy()
        var rules []*authv1beta1.AclRule

        for _, r := range policy </span><span class="cov0" title="0">{
                var rule authv1beta1.AclRule
                if len(r) &gt; 0 </span><span class="cov0" title="0">{
                        rule.Sub = r[0]
                }</span>
                <span class="cov0" title="0">if len(r) &gt; 1 </span><span class="cov0" title="0">{
                        rule.Obj = r[1]
                }</span>
                <span class="cov0" title="0">if len(r) &gt; 2 </span><span class="cov0" title="0">{
                        rule.Act = r[2]
                }</span>
                <span class="cov0" title="0">rules = append(rules, &amp;rule)</span>
        }
        <span class="cov0" title="0">return &amp;authv1beta1.ListRulesResponse{
                Rules: rules,
        }, nil</span>
}

func (s *AclAPI) AddRule(ctx context.Context, req *authv1beta1.AddRuleRequest) (*authv1beta1.AddRuleResponse, error) <span class="cov0" title="0">{
        scopes, ok := ctxutils.Scopes(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">if !scopes.Has(scope.ACLRuleWrite) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">rule := req.Rule
        if rule == nil </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("rule")
        }</span>

        <span class="cov0" title="0">if _, err := guid.Parse(rule.Obj); err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InvalidArgumentError("obj", err.Error())
        }</span>

        <span class="cov0" title="0">if rule.Act == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("act")
        }</span>

        <span class="cov0" title="0">ok, err := s.Enforcer.AddPolicy(rule.Sub, rule.Obj, rule.Act)
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                return &amp;authv1beta1.AddRuleResponse{Rule: rule}, nil
        }</span>

        <span class="cov0" title="0">return nil, twirp.NewError(twirp.AlreadyExists, "")</span>
}

func (s *AclAPI) DeleteRule(ctx context.Context, req *authv1beta1.DeleteRuleRequest) (*authv1beta1.DeleteRuleResponse, error) <span class="cov0" title="0">{
        scopes, ok := ctxutils.Scopes(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">if !scopes.Has(scope.ACLRuleDelete) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">rule := req.Rule
        if rule == nil </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("rule")
        }</span>

        <span class="cov0" title="0">if _, err := guid.Parse(rule.Obj); err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InvalidArgumentError("sub", err.Error())
        }</span>

        <span class="cov0" title="0">if rule.Act == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("act")
        }</span>

        <span class="cov0" title="0">ok, err := s.Enforcer.RemovePolicy(rule.Sub, rule.Obj, rule.Act)
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                return &amp;authv1beta1.DeleteRuleResponse{Rule: rule}, nil
        }</span>

        <span class="cov0" title="0">return nil, twirp.NotFoundError("")</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package authv1beta1api

import (
        "context"

        "github.com/enseadaio/enseada/pkg/log"

        "github.com/enseadaio/enseada/internal/ctxutils"

        "github.com/casbin/casbin/v2"
        "github.com/enseadaio/enseada/internal/auth"
        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/internal/guid"
        "github.com/enseadaio/enseada/internal/scope"
        authv1beta1 "github.com/enseadaio/enseada/rpc/auth/v1beta1"
        "github.com/go-kivik/kivik"
        "github.com/ory/fosite"
        "github.com/twitchtv/twirp"
)

type OAuthClientsAPI struct {
        Logger   log.Logger
        Enforcer *casbin.Enforcer
        Store    *auth.Store
}

func NewOAuthClientsAPI(logger log.Logger, enforcer *casbin.Enforcer, store *auth.Store) *OAuthClientsAPI <span class="cov0" title="0">{
        return &amp;OAuthClientsAPI{Logger: logger, Enforcer: enforcer, Store: store}
}</span>

func (o *OAuthClientsAPI) ListClients(ctx context.Context, req *authv1beta1.ListClientsRequest) (*authv1beta1.ListClientsResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
        if !scopes.Has(scope.OAuthClientRead) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">var cs []fosite.Client
        if id == "root" </span><span class="cov0" title="0">{
                clients, err := o.Store.ListClients(ctx, couch.Query{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, twirp.InternalErrorWith(err)
                }</span>

                <span class="cov0" title="0">cs = clients</span>
        } else<span class="cov0" title="0"> {
                ps := o.Enforcer.GetPermissionsForUser(id)
                ids := make([]string, 0)
                for _, p := range ps </span><span class="cov0" title="0">{
                        g, err := guid.Parse(p[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, twirp.InternalErrorWith(err)
                        }</span>

                        <span class="cov0" title="0">if g.DB() == couch.OAuthDB &amp;&amp; g.Kind() == couch.KindOAuthClient &amp;&amp; p[2] == "read" </span><span class="cov0" title="0">{
                                ids = append(ids, g.ID())
                        }</span>
                }

                <span class="cov0" title="0">clients, err := o.Store.ListClients(ctx, couch.Query{
                        "_id": couch.Query{
                                "$in": ids,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, twirp.InternalErrorWith(err)
                }</span>

                <span class="cov0" title="0">cs = clients</span>
        }

        <span class="cov0" title="0">var clients []*authv1beta1.OAuthClient

        for _, c := range cs </span><span class="cov0" title="0">{
                clients = append(clients, mapClientToProto(c))
        }</span>

        <span class="cov0" title="0">return &amp;authv1beta1.ListClientsResponse{
                Clients: clients,
        }, nil</span>
}

func (o *OAuthClientsAPI) GetClient(ctx context.Context, req *authv1beta1.GetClientRequest) (*authv1beta1.GetClientResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
        if !scopes.Has(scope.OAuthClientRead) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">if req.GetId() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("id")
        }</span>

        <span class="cov0" title="0">cg := guid.New(couch.OAuthDB, req.Id, couch.KindOAuthClient)
        can, err := o.Enforcer.Enforce(id, cg.String(), "read")
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">c, err := o.Store.GetClient(ctx, req.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if c == nil </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError(req.Id)
        }</span>

        <span class="cov0" title="0">return &amp;authv1beta1.GetClientResponse{
                Client: mapClientToProto(c),
        }, nil</span>
}

func (o *OAuthClientsAPI) CreateClient(ctx context.Context, req *authv1beta1.CreateClientRequest) (*authv1beta1.CreateClientResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
        if !scopes.Has(scope.OAuthClientWrite) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">pc := req.GetClient()
        if pc == nil </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("client")
        }</span>

        <span class="cov0" title="0">if pc.GetPublic() &amp;&amp; req.GetSecret() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("client secret")
        }</span>

        <span class="cov0" title="0">c, err := mapProtoToClient(pc, req.GetSecret())
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">err = o.Store.SaveClient(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                if kivik.StatusCode(err) == kivik.StatusConflict </span><span class="cov0" title="0">{
                        return nil, twirp.NewError(twirp.AlreadyExists, "")
                }</span>
                <span class="cov0" title="0">return nil, twirp.InternalErrorWith(err)</span>
        }

        <span class="cov0" title="0">cg := guid.New(couch.OAuthDB, c.GetID(), couch.KindOAuthClient)
        ps := []string{"read", "update", "delete"}
        for _, p := range ps </span><span class="cov0" title="0">{
                _, err := o.Enforcer.AddPermissionForUser(id, cg.String(), p)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, twirp.InternalErrorWith(err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;authv1beta1.CreateClientResponse{
                Client: mapClientToProto(c),
        }, nil</span>
}

func (o *OAuthClientsAPI) UpdateClient(ctx context.Context, req *authv1beta1.UpdateClientRequest) (*authv1beta1.UpdateClientResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
        if !scopes.Has(scope.OAuthClientWrite) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">pc := req.GetClient()
        if pc == nil </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("client")
        }</span>

        <span class="cov0" title="0">fc, err := o.Store.GetClient(ctx, pc.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if fc == nil </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">c := fc.(*auth.OAuthClient)

        cg := guid.New(couch.OAuthDB, c.GetID(), couch.KindOAuthClient)
        can, err := o.Enforcer.Enforce(id, cg.String(), "update")
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">if pc.GetRedirectUris() != nil </span><span class="cov0" title="0">{
                c.RedirectURIs = pc.GetRedirectUris()
        }</span>
        <span class="cov0" title="0">if pc.GetGrantTypes() != nil </span><span class="cov0" title="0">{
                c.GrantTypes = pc.GetGrantTypes()
        }</span>
        <span class="cov0" title="0">if pc.GetResponseTypes() != nil </span><span class="cov0" title="0">{
                c.ResponseTypes = pc.GetResponseTypes()
        }</span>
        <span class="cov0" title="0">if pc.GetScopes() != nil </span><span class="cov0" title="0">{
                c.Scopes = pc.GetScopes()
        }</span>
        <span class="cov0" title="0">if pc.GetAudiences() != nil </span><span class="cov0" title="0">{
                c.Audiences = pc.GetAudiences()
        }</span>

        <span class="cov0" title="0">err = o.Store.SaveClient(ctx, c)
        return &amp;authv1beta1.UpdateClientResponse{
                Client: mapClientToProto(c),
        }, nil</span>
}

func (o *OAuthClientsAPI) DeleteClient(ctx context.Context, req *authv1beta1.DeleteClientRequest) (*authv1beta1.DeleteClientResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
        if !scopes.Has(scope.OAuthClientWrite) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">if req.GetId() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("id")
        }</span>

        <span class="cov0" title="0">cg := guid.New(couch.OAuthDB, req.GetId(), couch.KindOAuthClient)
        can, err := o.Enforcer.Enforce(id, cg, "delete")
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">c, err := o.Store.DeleteClient(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if c == nil </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">ps := []string{"read", "update", "delete"}
        for _, p := range ps </span><span class="cov0" title="0">{
                _, err := o.Enforcer.DeletePermissionForUser(id, cg.String(), p)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, twirp.InternalErrorWith(err)
                }</span>
        }
        <span class="cov0" title="0">return &amp;authv1beta1.DeleteClientResponse{
                Client: mapClientToProto(c),
        }, nil</span>
}

func mapClientToProto(c fosite.Client) *authv1beta1.OAuthClient <span class="cov0" title="0">{
        return &amp;authv1beta1.OAuthClient{
                Id:            c.GetID(),
                RedirectUris:  c.GetRedirectURIs(),
                GrantTypes:    c.GetGrantTypes(),
                ResponseTypes: c.GetResponseTypes(),
                Scopes:        c.GetScopes(),
                Audiences:     c.GetAudience(),
                Public:        c.IsPublic(),
        }
}</span>

func mapProtoToClient(c *authv1beta1.OAuthClient, secret string) (fosite.Client, error) <span class="cov0" title="0">{
        return auth.NewOAuthClient(c.GetId(), secret,
                auth.OAuthRedirectURIs(c.GetRedirectUris()...),
                auth.OAuthGrantTypes(c.GetGrantTypes()...),
                auth.OAuthResponseTypes(c.GetResponseTypes()...),
                auth.OAuthScopes(c.GetScopes()...),
                auth.OAuthAudiences(c.GetAudiences()...),
                auth.OAuthPublic(c.GetPublic()),
        )
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package authv1beta1api

import (
        "context"

        "github.com/enseadaio/enseada/internal/ctxutils"
        "github.com/enseadaio/enseada/pkg/log"

        "github.com/casbin/casbin/v2"
        "github.com/enseadaio/enseada/internal/auth"
        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/internal/guid"
        authv1beta1 "github.com/enseadaio/enseada/rpc/auth/v1beta1"
        "github.com/go-kivik/kivik"
        "github.com/twitchtv/twirp"
)

type UsersAPI struct {
        Logger   log.Logger
        Enforcer *casbin.Enforcer
        Store    *auth.Store
}

func NewUsersAPI(logger log.Logger, enforcer *casbin.Enforcer, store *auth.Store) *UsersAPI <span class="cov0" title="0">{
        return &amp;UsersAPI{Logger: logger, Enforcer: enforcer, Store: store}
}</span>

func (u *UsersAPI) ListUsers(ctx context.Context, req *authv1beta1.ListUsersRequest) (*authv1beta1.ListUsersResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">can, err := u.Enforcer.Enforce(id, guid.New(couch.UsersDB, "*", couch.KindUser).String(), "read")
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "")
        }</span>

        <span class="cov0" title="0">us, err := u.Store.ListUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">ups := make([]*authv1beta1.User, len(us))
        for i, u := range us </span><span class="cov0" title="0">{
                up := &amp;authv1beta1.User{
                        Username: u.Username,
                }
                ups[i] = up
        }</span>

        <span class="cov0" title="0">return &amp;authv1beta1.ListUsersResponse{
                Users: ups,
        }, nil</span>
}

func (u *UsersAPI) GetUser(ctx context.Context, req *authv1beta1.GetUserRequest) (*authv1beta1.GetUserResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">can, err := u.Enforcer.Enforce(id, guid.New(couch.UsersDB, "*", couch.KindUser).String(), "read")
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "")
        }</span>

        <span class="cov0" title="0">if req.GetUsername() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("username")
        }</span>

        <span class="cov0" title="0">user, err := u.Store.GetUser(ctx, req.GetUsername())
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">up := &amp;authv1beta1.User{
                Username: user.Username,
        }

        return &amp;authv1beta1.GetUserResponse{
                User: up,
        }, nil</span>
}

func (u *UsersAPI) CreateUser(ctx context.Context, req *authv1beta1.CreateUserRequest) (*authv1beta1.CreateUserResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">can, err := u.Enforcer.Enforce(id, guid.New(couch.UsersDB, "*", couch.KindUser).String(), "write")
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "")
        }</span>

        <span class="cov0" title="0">up := req.GetUser()
        if up == nil </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("user")
        }</span>

        <span class="cov0" title="0">pwd := req.GetPassword()
        if pwd == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("password")
        }</span>

        <span class="cov0" title="0">uu := &amp;auth.User{
                Username: up.GetUsername(),
                Password: pwd,
        }
        err = u.Store.SaveUser(ctx, uu)
        if err != nil </span><span class="cov0" title="0">{
                // Don't like it, leaking db implementation
                if kivik.StatusCode(err) == kivik.StatusConflict </span><span class="cov0" title="0">{
                        e := twirp.NewError(twirp.AlreadyExists, "")
                        e = e.WithMeta("username", up.GetUsername())
                        return nil, e
                }</span>
                <span class="cov0" title="0">return nil, twirp.InternalErrorWith(err)</span>
        }

        <span class="cov0" title="0">return &amp;authv1beta1.CreateUserResponse{
                User: up,
        }, nil</span>
}

func (u *UsersAPI) UpdateUserPassword(ctx context.Context, req *authv1beta1.UpdateUserPasswordRequest) (*authv1beta1.UpdateUserPasswordResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">uu, err := u.Store.GetUser(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.GetPassword() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("password")
        }</span>

        <span class="cov0" title="0">uu.Password = req.GetPassword()
        err = u.Store.UpdateUser(ctx, uu)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;authv1beta1.UpdateUserPasswordResponse{}, nil</span>
}

func (u *UsersAPI) DeleteUser(ctx context.Context, req *authv1beta1.DeleteUserRequest) (*authv1beta1.DeleteUserResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">can, err := u.Enforcer.Enforce(id, guid.New(couch.UsersDB, "*", couch.KindUser).String(), "write")
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "")
        }</span>

        <span class="cov0" title="0">if req.GetUsername() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("username")
        }</span>

        <span class="cov0" title="0">if req.GetUsername() == id </span><span class="cov0" title="0">{
                return nil, twirp.InvalidArgumentError("username", "cannot be the currently authenticated user")
        }</span>

        <span class="cov0" title="0">uu, err := u.Store.GetUser(ctx, req.GetUsername())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if uu == nil </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">err = u.Store.DeleteUser(ctx, uu)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;authv1beta1.DeleteUserResponse{
                User: &amp;authv1beta1.User{
                        Username: uu.Username,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package couch

import (
        "context"

        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
)

func InitDb(ctx context.Context, logger log.Logger, client *kivik.Client, name string) error <span class="cov0" title="0">{
        does, err := client.DBExists(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !does </span><span class="cov0" title="0">{
                logger.Infof("initializing database %s", name)
                return client.CreateDB(ctx, name)
        }</span>
        <span class="cov0" title="0">logger.Infof("database %s already exists", name)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package couch

import (
        "context"
        "fmt"

        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
)

func InitIndex(ctx context.Context, logger log.Logger, client *kivik.Client, dbName string, name string, idx map[string]interface{}) error <span class="cov0" title="0">{
        db := client.DB(ctx, dbName)
        logger.Infof("initializing index %s on db %s", name, dbName)
        return db.CreateIndex(ctx, fmt.Sprintf("%s_idx", name), name, idx)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package couch

import (
        "context"

        "github.com/enseadaio/enseada/pkg/log"

        "github.com/go-kivik/kivik"
        "github.com/pkg/errors"
)

const (
        MavenDB = "maven2"
        OAuthDB = "oauth"
        UsersDB = "users"
        AclDB   = "acl"
)

func Transact(ctx context.Context, logger log.Logger, client *kivik.Client, f func(context.Context, log.Logger, *kivik.Client) error, dbname string) error <span class="cov0" title="0">{
        if err := f(ctx, logger, client); err != nil </span><span class="cov0" title="0">{
                e := client.DestroyDB(ctx, dbname)
                if e != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, e.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package ctxutils

import (
        "context"

        "github.com/ory/fosite"
)

type contextKey int

const (
        currentUserID contextKey = 1 + iota
        scopes
)

func CurrentUserID(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        g, ok := ctx.Value(currentUserID).(string)
        return g, ok
}</span>

func WithCurrentUserID(ctx context.Context, g string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, currentUserID, g)
}</span>

func Scopes(ctx context.Context) (fosite.Arguments, bool) <span class="cov0" title="0">{
        s, ok := ctx.Value(scopes).(fosite.Arguments)
        return s, ok
}</span>

func WithScopes(ctx context.Context, s fosite.Arguments) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, scopes, s)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package guid

import (
        "errors"
        "net/url"
        "strings"

        "github.com/enseadaio/enseada/internal/couch"
)

type GUID struct {
        db   string
        id   string
        rev  string
        kind couch.Kind
        s    string
}

func New(db string, id string, kind couch.Kind) GUID <span class="cov7" title="3">{
        return GUID{
                db:   db,
                id:   id,
                kind: kind,
        }
}</span>

func NewWithRev(db string, id string, kind couch.Kind, rev string) GUID <span class="cov7" title="3">{
        return GUID{
                db:   db,
                id:   id,
                kind: kind,
                rev:  rev,
        }
}</span>

func Parse(guid string) (GUID, error) <span class="cov10" title="5">{
        if guid == "" </span><span class="cov1" title="1">{
                return GUID{}, errors.New("GUID can't be blank")
        }</span>

        <span class="cov8" title="4">if !strings.Contains(guid, "://") </span><span class="cov1" title="1">{
                return GUID{}, errors.New("is missing database")
        }</span>

        <span class="cov7" title="3">s1 := strings.Split(guid, "://")
        db := s1[0]
        id := s1[1]
        if id == "" </span><span class="cov1" title="1">{
                return GUID{}, errors.New("is missing Username")
        }</span>

        <span class="cov4" title="2">query := url.Values{}
        if strings.Contains(id, "?") </span><span class="cov4" title="2">{
                s2 := strings.Split(id, "?")
                id = s2[0]
                q, err := url.ParseQuery(s2[1])
                if err != nil </span><span class="cov0" title="0">{
                        return GUID{}, err
                }</span>
                <span class="cov4" title="2">query = q</span>
        }

        <span class="cov4" title="2">k := query.Get("kind")
        if k == "" </span><span class="cov0" title="0">{
                return GUID{}, errors.New("is missing kind")
        }</span>

        <span class="cov4" title="2">kind := couch.Kind(k)

        if rev := query.Get("rev"); rev != "" </span><span class="cov1" title="1">{
                return NewWithRev(db, id, kind, rev), nil
        }</span>
        <span class="cov1" title="1">return New(db, id, kind), nil</span>
}

func (g GUID) DB() string <span class="cov0" title="0">{
        return g.db
}</span>

func (g GUID) ID() string <span class="cov0" title="0">{
        return g.id
}</span>

func (g GUID) Kind() couch.Kind <span class="cov0" title="0">{
        return g.kind
}</span>

func (g GUID) Rev() string <span class="cov0" title="0">{
        return g.rev
}</span>

func (g GUID) String() string <span class="cov4" title="2">{
        if g.s == "" </span><span class="cov4" title="2">{
                var s strings.Builder
                s.WriteString(g.db)
                s.WriteString("://")
                s.WriteString(g.id)
                s.WriteString("?kind=")
                s.WriteString(string(g.kind))
                if g.rev != "" </span><span class="cov1" title="1">{
                        s.WriteString("&amp;rev=")
                        s.WriteString(g.rev)
                }</span>
                <span class="cov4" title="2">g.s = s.String()</span>
        }

        <span class="cov4" title="2">return g.s</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package maven

import (
        "errors"
        "fmt"
)

func formatError(format string, args ...interface{}) error <span class="cov0" title="0">{
        return errors.New(fmt.Sprintf(format, args...))
}</span>

var (
        ErrorRepoAlreadyPresent = errors.New("repository already present")
        ErrorRepoNotFound       = errors.New("repository not found")
        ErrorTooManyFilesForKey = func(expected, actual int) error <span class="cov0" title="0">{
                return formatError("too many files found. Expected %d, found %d", expected, actual)
        }</span>
        ErrorInvalidRepoId = func(id string) error <span class="cov0" title="0">{
                return formatError("invalid repo id. %s is not a valid Maven repo identifier", id)
        }</span>
)
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package maven

import (
        "context"
        "fmt"
        "sort"
        "strings"

        "github.com/chartmuseum/storage"

        "github.com/enseadaio/enseada/internal/couch"
)

const StoragePrefix = couch.MavenDB

type RepoFile struct {
        Repo     *Repo
        Filename string
        Version  string
        content  []byte
        path     string
        storage  storage.Backend
}

func (f *RepoFile) Content() ([]byte, error) <span class="cov0" title="0">{
        if f.content == nil </span><span class="cov0" title="0">{
                obj, err := f.storage.GetObject(f.path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">f.content = obj.Content</span>
        }
        <span class="cov0" title="0">return f.content, nil</span>
}
func (m *Maven) GetFile(ctx context.Context, path string) (*RepoFile, error) <span class="cov0" title="0">{
        m.Logger.Infof("looking up file with path %s", fmt.Sprintf(`"%s"`, path))
        repo, err := m.FindRepo(ctx, couch.Query{
                "files": couch.Query{
                        "$elemMatch": couch.Query{
                                "$eq": path,
                        },
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if repo == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">slices := strings.Split(path, "/")
        return &amp;RepoFile{
                Repo:     repo,
                Filename: slices[len(slices)-1],
                path:     path,
                storage:  m.storage,
        }, nil</span>
}

func (m *Maven) PutFile(ctx context.Context, path string, content []byte) error <span class="cov0" title="0">{
        return m.storage.PutObject(path, content)
}</span>

func (m *Maven) PutFileInRepo(ctx context.Context, repo *Repo, path string, content []byte) (*RepoFile, error) <span class="cov0" title="0">{
        trimmed := strings.TrimPrefix(path, repo.StoragePath)
        trimmed = strings.TrimPrefix(trimmed, "/")
        slices := strings.Split(trimmed, "/")
        filename := slices[len(slices)-1]
        var version string
        if len(slices) == 2 </span><span class="cov0" title="0">{
                version = slices[0]
        }</span>
        <span class="cov0" title="0">file := &amp;RepoFile{
                Repo:     repo,
                Filename: filename,
                Version:  version,
                content:  content,
        }
        m.Logger.Infof("storing file %+v", file)
        spath := filePath(file)
        err := m.PutFile(ctx, spath, content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">repo.Files = append(repo.Files, spath)
        in := repo.Files
        sort.Strings(in)
        j := 0
        for i := 1; i &lt; len(in); i++ </span><span class="cov0" title="0">{
                if in[j] == in[i] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">j++
                in[j] = in[i]</span>
        }
        <span class="cov0" title="0">repo.Files = in[:j+1]
        return file, m.SaveRepo(ctx, repo)</span>
}

func (m *Maven) ClearRepoStorage(ctx context.Context, repo *Repo) error <span class="cov0" title="0">{
        prefix := fmt.Sprintf("%s/%s/", StoragePrefix, repo.StoragePath)
        objs, err := m.storage.ListObjects(prefix)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, obj := range objs </span><span class="cov0" title="0">{
                if err := m.storage.DeleteObject(prefix + obj.Path); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">repo.Files = []string{}
        return m.SaveRepo(ctx, repo)</span>
}

func filePath(file *RepoFile) string <span class="cov0" title="0">{
        repo := file.Repo
        if file.Version == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s/%s/%s", StoragePrefix, repo.StoragePath, file.Filename)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%s/%s/%s/%s", StoragePrefix, repo.StoragePath, file.Version, file.Filename)
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package maven

import (
        "github.com/chartmuseum/storage"
        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
)

type Maven struct {
        Logger  log.Logger
        data    *kivik.Client
        storage storage.Backend
}

func New(logger log.Logger, data *kivik.Client, storage storage.Backend) *Maven <span class="cov0" title="0">{
        return &amp;Maven{
                Logger:  logger,
                data:    data,
                storage: storage,
        }
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package maven

import (
        "bytes"
        "context"
        "crypto/md5"
        "crypto/sha1"
        "fmt"
        "strings"
        "text/template"
        "time"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/go-kivik/kivik"
)

const baseMetadataFile = `
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;metadata&gt;
        &lt;groupId&gt;{{ .GroupId }}&lt;/groupId&gt;
        &lt;artifactId&gt;{{ .ArtifactId }}&lt;/artifactId&gt;
        &lt;versioning&gt;
                &lt;versions&gt;&lt;/versions&gt;
                &lt;lastUpdated&gt;{{ .TimeStamp }}&lt;/lastUpdated&gt;
        &lt;/versioning&gt;
&lt;/metadata&gt;
`

type Repo struct {
        ID          string     `json:"_id,omitempty"`
        Rev         string     `json:"_rev,omitempty"`
        GroupID     string     `json:"group_id"`
        ArtifactID  string     `json:"artifact_id"`
        StoragePath string     `json:"storage_path"`
        Files       []string   `json:"files"`
        Kind        couch.Kind `json:"kind"`
}

func NewRepo(groupID string, artifactID string) Repo <span class="cov0" title="0">{
        group := strings.ReplaceAll(groupID, ".", "/")
        return Repo{
                ID:          repoID(groupID, artifactID),
                GroupID:     groupID,
                ArtifactID:  artifactID,
                StoragePath: strings.Join([]string{group, artifactID}, "/"),
                Kind:        couch.KindRepository,
        }
}</span>

func (m *Maven) ListRepos(ctx context.Context, selector couch.Query) ([]*Repo, error) <span class="cov0" title="0">{
        db := m.data.DB(ctx, couch.MavenDB)
        s := couch.Query{
                "kind": couch.KindRepository,
        }
        if len(selector) &gt; 0 </span><span class="cov0" title="0">{
                delete(selector, "kind")
                for k, v := range selector </span><span class="cov0" title="0">{
                        s[k] = v
                }</span>

        }

        <span class="cov0" title="0">rows, err := db.Find(ctx, couch.Query{
                "selector": s,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">repos := make([]*Repo, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var repo Repo
                if err := rows.ScanDoc(&amp;repo); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">repos = append(repos, &amp;repo)</span>
        }
        <span class="cov0" title="0">if rows.Err() != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return repos, nil</span>
}

func (m *Maven) GetRepo(ctx context.Context, id string) (*Repo, error) <span class="cov0" title="0">{
        db := m.data.DB(ctx, couch.MavenDB)
        row := db.Get(ctx, id)
        repo := &amp;Repo{}
        if err := row.ScanDoc(repo); err != nil </span><span class="cov0" title="0">{
                if kivik.StatusCode(err) == kivik.StatusNotFound </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return repo, nil</span>
}

func (m *Maven) GetRepoByCoordinates(ctx context.Context, groupID string, artifactID string) (*Repo, error) <span class="cov0" title="0">{
        return m.GetRepo(ctx, repoID(groupID, artifactID))
}</span>

func (m *Maven) FindRepo(ctx context.Context, selector couch.Query) (*Repo, error) <span class="cov0" title="0">{
        s := couch.Query{
                "kind": couch.KindRepository,
        }

        if len(selector) &gt; 0 </span><span class="cov0" title="0">{
                delete(selector, "kind")
                for k, v := range selector </span><span class="cov0" title="0">{
                        s[k] = v
                }</span>

        }

        <span class="cov0" title="0">db := m.data.DB(ctx, couch.MavenDB)
        rows, err := db.Find(ctx, couch.Query{
                "selector": s,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if rows.Next() </span><span class="cov0" title="0">{
                repo := new(Repo)
                if err := rows.ScanDoc(repo); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return repo, nil</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

func (m *Maven) SaveRepo(ctx context.Context, repo *Repo) error <span class="cov0" title="0">{
        db := m.data.DB(ctx, couch.MavenDB)
        if repo.Rev == "" </span><span class="cov0" title="0">{
                _, rev, err := db.GetMeta(ctx, repo.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">repo.Rev = rev</span>
        }

        <span class="cov0" title="0">rev, err := db.Put(ctx, repo.ID, repo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">repo.Rev = rev
        return err</span>
}

func (m *Maven) DeleteRepo(ctx context.Context, id string) (*Repo, error) <span class="cov0" title="0">{
        db := m.data.DB(ctx, couch.MavenDB)
        repo, err := m.GetRepo(ctx, id)
        if err != nil || repo == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := m.ClearRepoStorage(ctx, repo); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rev, err := db.Delete(ctx, repo.ID, repo.Rev)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">repo.Rev = rev
        return repo, nil</span>
}

func repoID(groupID string, artifactID string) string <span class="cov0" title="0">{
        return strings.Join([]string{groupID, artifactID}, ":")
}</span>

func (m *Maven) InitRepo(ctx context.Context, repo *Repo) error <span class="cov0" title="0">{
        db := m.data.DB(ctx, couch.MavenDB)

        m.Logger.Infof("Initializing repo %s", repo.ID)
        err := save(ctx, db, repo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m.Logger.Infof("Created repo %s", repo.ID)
        t, err := template.New("maven-metadata.xml").Parse(baseMetadataFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var buf bytes.Buffer
        err = t.Execute(&amp;buf, map[string]interface{}{
                "GroupId":    repo.GroupID,
                "ArtifactId": repo.ArtifactID,
                "TimeStamp":  time.Now().Unix(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m.Logger.Infof("Creating file %s", t.ParseName)
        file := &amp;RepoFile{
                Repo:     repo,
                Filename: t.ParseName,
                content:  buf.Bytes(),
        }

        md5sum := &amp;RepoFile{
                Repo:     repo,
                Filename: fmt.Sprintf("%s.md5", t.ParseName),
                content:  []byte(fmt.Sprintf("%x", md5.Sum(file.content))),
        }

        sha1sum := &amp;RepoFile{
                Repo:     repo,
                Filename: fmt.Sprintf("%s.sha1", t.ParseName),
                content:  []byte(fmt.Sprintf("%x", sha1.Sum(file.content))),
        }

        path := filePath(file)
        repo.Files = append(repo.Files, path)
        err = m.PutFile(ctx, path, file.content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">path = filePath(md5sum)
        repo.Files = append(repo.Files, path)
        err = m.PutFile(ctx, path, md5sum.content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">path = filePath(sha1sum)
        repo.Files = append(repo.Files, path)
        err = m.PutFile(ctx, path, sha1sum.content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return save(ctx, db, repo)</span>
}

func save(ctx context.Context, db *kivik.DB, repo *Repo) error <span class="cov0" title="0">{
        rev, err := db.Put(ctx, repo.ID, repo)
        if err != nil </span><span class="cov0" title="0">{
                switch kivik.StatusCode(err) </span>{
                case kivik.StatusConflict:<span class="cov0" title="0">
                        return ErrorRepoAlreadyPresent</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }
        <span class="cov0" title="0">repo.Rev = rev
        return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package mavenv1beta1api

import (
        "context"

        "github.com/enseadaio/enseada/internal/ctxutils"

        "github.com/casbin/casbin/v2"
        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/internal/guid"
        "github.com/enseadaio/enseada/internal/maven"
        "github.com/enseadaio/enseada/internal/scope"
        mavenv1beta1 "github.com/enseadaio/enseada/rpc/maven/v1beta1"
        "github.com/twitchtv/twirp"
)

type Service struct {
        Maven    *maven.Maven
        Enforcer *casbin.Enforcer
}

func (s Service) ListRepos(ctx context.Context, req *mavenv1beta1.ListReposRequest) (*mavenv1beta1.ListReposResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
        if !scopes.Has(scope.MavenRepoRead) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">var repos []*maven.Repo
        if id == "root" </span><span class="cov0" title="0">{
                rs, err := s.Maven.ListRepos(ctx, couch.Query{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, twirp.InternalErrorWith(err)
                }</span>

                <span class="cov0" title="0">repos = rs</span>
        } else<span class="cov0" title="0"> {
                ps := s.Enforcer.GetPermissionsForUser(id)
                ids := make([]string, 0)
                for _, p := range ps </span><span class="cov0" title="0">{
                        g, err := guid.Parse(p[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, twirp.InternalErrorWith(err)
                        }</span>

                        <span class="cov0" title="0">if g.DB() == couch.MavenDB &amp;&amp; g.Kind() == couch.KindRepository &amp;&amp; p[2] == "read" </span><span class="cov0" title="0">{
                                ids = append(ids, g.ID())
                        }</span>
                }

                <span class="cov0" title="0">rs, err := s.Maven.ListRepos(ctx, couch.Query{
                        "_id": couch.Query{
                                "$in": ids,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, twirp.InternalErrorWith(err)
                }</span>

                <span class="cov0" title="0">repos = rs</span>
        }
        <span class="cov0" title="0">rs := make([]*mavenv1beta1.Repo, len(repos))
        for i, repo := range repos </span><span class="cov0" title="0">{
                r := &amp;mavenv1beta1.Repo{
                        Id:         repo.ID,
                        GroupId:    repo.GroupID,
                        ArtifactId: repo.ArtifactID,
                }
                rs[i] = r
        }</span>

        <span class="cov0" title="0">return &amp;mavenv1beta1.ListReposResponse{
                Repos: rs,
        }, nil</span>
}

func (s Service) GetRepo(ctx context.Context, req *mavenv1beta1.GetRepoRequest) (*mavenv1beta1.GetRepoResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
        if !scopes.Has(scope.MavenRepoRead) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">if req.GetId() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("id")
        }</span>

        <span class="cov0" title="0">cg := guid.New(couch.MavenDB, req.GetId(), couch.KindRepository)
        can, err := s.Enforcer.Enforce(id, cg.String(), "read")
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">repo, err := s.Maven.GetRepo(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if repo == nil </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">return &amp;mavenv1beta1.GetRepoResponse{
                Repo: &amp;mavenv1beta1.Repo{
                        Id:         repo.ID,
                        GroupId:    repo.GroupID,
                        ArtifactId: repo.ArtifactID,
                },
        }, nil</span>
}

func (s Service) CreateRepo(ctx context.Context, req *mavenv1beta1.CreateRepoRequest) (*mavenv1beta1.CreateRepoResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
        if !scopes.Has(scope.MavenRepoWrite) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">if req.GetGroupId() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("group_id")
        }</span>

        <span class="cov0" title="0">if req.GetArtifactId() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("artifact_id")
        }</span>

        <span class="cov0" title="0">repo := maven.NewRepo(req.GroupId, req.ArtifactId)
        err := s.Maven.InitRepo(ctx, &amp;repo)
        if err != nil </span><span class="cov0" title="0">{
                if err == maven.ErrorRepoAlreadyPresent </span><span class="cov0" title="0">{
                        return nil, twirp.NewError(twirp.AlreadyExists, "Maven repository already present")
                }</span>
                <span class="cov0" title="0">return nil, twirp.InternalErrorWith(err)</span>
        }

        <span class="cov0" title="0">cg := guid.New(couch.MavenDB, repo.ID, couch.KindRepository)
        ps := []string{"read", "update", "write", "delete"}
        for _, p := range ps </span><span class="cov0" title="0">{
                _, err := s.Enforcer.AddPermissionForUser(id, cg.String(), p)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, twirp.InternalErrorWith(err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;mavenv1beta1.CreateRepoResponse{
                Repo: &amp;mavenv1beta1.Repo{
                        Id:         repo.ID,
                        GroupId:    repo.GroupID,
                        ArtifactId: repo.ArtifactID,
                },
        }, nil</span>
}

func (s Service) DeleteRepo(ctx context.Context, req *mavenv1beta1.DeleteRepoRequest) (*mavenv1beta1.DeleteRepoResponse, error) <span class="cov0" title="0">{
        id, ok := ctxutils.CurrentUserID(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.Unauthenticated, "")
        }</span>

        <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
        if !scopes.Has(scope.MavenRepoWrite) </span><span class="cov0" title="0">{
                return nil, twirp.NewError(twirp.PermissionDenied, "insufficient scopes")
        }</span>

        <span class="cov0" title="0">if req.GetId() == "" </span><span class="cov0" title="0">{
                return nil, twirp.RequiredArgumentError("id")
        }</span>

        <span class="cov0" title="0">cg := guid.New(couch.MavenDB, req.GetId(), couch.KindRepository)
        can, err := s.Enforcer.Enforce(id, cg.String(), "delete")
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">repo, err := s.Maven.DeleteRepo(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">if repo == nil </span><span class="cov0" title="0">{
                return nil, twirp.NotFoundError("")
        }</span>

        <span class="cov0" title="0">return &amp;mavenv1beta1.DeleteRepoResponse{
                Repo: &amp;mavenv1beta1.Repo{
                        Id:         repo.ID,
                        GroupId:    repo.GroupID,
                        ArtifactId: repo.ArtifactID,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package middleware

import (
        "encoding/base64"
        "fmt"
        "net/http"
        "strings"

        "github.com/enseadaio/enseada/internal/scope"

        "github.com/enseadaio/enseada/pkg/log"

        "github.com/enseadaio/enseada/internal/ctxutils"

        "github.com/enseadaio/enseada/internal/auth"
        "github.com/ory/fosite"
)

func AuthorizationHeader(logger log.Logger, s *auth.Store, op fosite.OAuth2Provider) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(base http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if strings.HasPrefix(r.RequestURI, "/oauth") </span><span class="cov0" title="0">{
                                base.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">h := r.Header.Get("authorization")
                        if h == "" </span><span class="cov0" title="0">{
                                base.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">ctx := r.Context()
                        slices := strings.Split(h, " ")
                        if len(slices) != 2 </span><span class="cov0" title="0">{
                                base.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">prefix := strings.ToLower(strings.TrimSpace(slices[0]))
                        content := strings.TrimSpace(slices[1])

                        var token string
                        switch prefix </span>{
                        case "basic":<span class="cov0" title="0">
                                d, err := base64.StdEncoding.DecodeString(content)
                                if err != nil </span><span class="cov0" title="0">{
                                        http.Error(w, err.Error(), http.StatusBadRequest)
                                        return
                                }</span>
                                <span class="cov0" title="0">up := strings.Split(string(d), ":")
                                if len(up) != 2 </span><span class="cov0" title="0">{
                                        logger.Errorf("authentication failed: %s", d)
                                        http.Error(w, fmt.Sprintf("not a valid Basic auth value: %s", d), http.StatusBadRequest)
                                        return
                                }</span>
                                <span class="cov0" title="0">if up[0] != "x-oauth-token" </span><span class="cov0" title="0">{
                                        http.Error(w,
                                                "invalid username. HTTP Basic auth requires special user 'x-oauth-token' with a valid OAuth 2.0 token as password",
                                                http.StatusUnauthorized)
                                        return
                                }</span>
                                <span class="cov0" title="0">token = up[1]</span>
                        case "bearer":<span class="cov0" title="0">
                                token = content</span>
                        default:<span class="cov0" title="0">
                                logger.Warnf("unknown authentication strategy: %s", prefix)
                                base.ServeHTTP(w, r)
                                return</span>
                        }

                        <span class="cov0" title="0">ss := auth.NewSession(nil)
                        tt, ar, err := op.IntrospectToken(ctx, token, fosite.AccessToken, ss)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err)
                                http.Error(w, err.Error(), http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Infof("successfully validated token of type %s", tt)
                        id := ar.GetSession().GetSubject()
                        u, err := s.GetUser(ctx, id)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err)
                                http.Error(w, err.Error(), http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov0" title="0">logger.Infof("successfully authenticated user %s", u.Username)
                        ctx = ctxutils.WithCurrentUserID(ctx, u.Username)

                        scs := make([]string, 0)
                        for _, s := range scope.All </span><span class="cov0" title="0">{
                                if fosite.WildcardScopeStrategy(ar.GetGrantedScopes(), s) </span><span class="cov0" title="0">{
                                        scs = append(scs, s)
                                }</span>
                        }
                        <span class="cov0" title="0">ctx = ctxutils.WithScopes(ctx, scs)

                        r = r.WithContext(ctx)
                        base.ServeHTTP(w, r)
                        return</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package middleware

import (
        "time"

        session "github.com/ipfans/echo-session"
        "github.com/labstack/echo"
)

func Session(skb []byte) echo.MiddlewareFunc <span class="cov0" title="0">{
        exp := (time.Hour * 720).Seconds()
        s := session.NewCookieStore(skb)
        s.Options(session.Options{
                MaxAge:   int(exp),
                HttpOnly: true,
        })
        return session.Sessions("enseada-session", s)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package utils

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/labstack/echo"
)

type HTTPErrorBody struct {
        Error   string `json:"error"`
        Message string `json:"message"`
}

func HTTPError(status int, format string, args ...interface{}) HTTPErrorBody <span class="cov0" title="0">{
        err := http.StatusText(status)
        err = strings.ToLower(err)
        err = strings.ReplaceAll(err, " ", "_")
        msg := format
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                msg = fmt.Sprintf(format, args...)
        }</span>

        <span class="cov0" title="0">return HTTPErrorBody{
                Error:   err,
                Message: msg,
        }</span>
}

func QueryWithDefault(c echo.Context, name string, def string) string <span class="cov0" title="0">{
        p := c.QueryParam(name)
        if p == "" </span><span class="cov0" title="0">{
                return def
        }</span>

        <span class="cov0" title="0">return p</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "context"
        "crypto/rand"
        "crypto/rsa"

        "github.com/enseadaio/enseada/pkg/log"

        rice "github.com/GeertJohan/go.rice"
        "github.com/casbin/casbin/v2"
        "github.com/casbin/casbin/v2/model"
        "github.com/enseadaio/enseada/internal/auth"
        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/internal/middleware"
        "github.com/go-kivik/kivik"
        "github.com/labstack/echo"
        "github.com/ory/fosite"
        "github.com/ory/fosite/compose"
)

type Components struct {
        Store    *auth.Store
        Enforcer *casbin.Enforcer
        Watcher  *CasbinWatcher
        Provider fosite.OAuth2Provider
}

func Boot(ctx context.Context, e *echo.Echo, data *kivik.Client, logger log.Logger, skb []byte, ph string, clientSecret string) (*Components, error) <span class="cov0" title="0">{
        if err := couch.Transact(ctx, logger, data, migrateAclDb, couch.AclDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := couch.Transact(ctx, logger, data, migrateOAuthDb, couch.OAuthDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := couch.Transact(ctx, logger, data, migrateUsersDb, couch.UsersDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s := createStore(data, logger)

        enf, w, err := createCasbin(data, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">key, err := rsa.GenerateKey(rand.Reader, 4096)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">op := compose.ComposeAllEnabled(
                &amp;compose.Config{},
                s,
                skb,
                key,
        )

        err = s.InitDefaultClients(ctx, ph, clientSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">root := auth.RootUser("root")
        if err := s.SaveUser(ctx, root); err != nil &amp;&amp; kivik.StatusCode(err) != kivik.StatusConflict </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">mountRoutes(e, s, op, enf, middleware.Session(skb))
        return &amp;Components{
                Store:    s,
                Enforcer: enf,
                Watcher:  w,
                Provider: op,
        }, nil</span>
}

func createStore(data *kivik.Client, logger log.Logger) *auth.Store <span class="cov0" title="0">{
        oAuthClientStore := auth.NewOAuthClientStore(data, logger)
        oAuthRequestStore := auth.NewOAuthRequestStore(data, logger)
        oidcSessionStore := auth.NewOIDCSessionStore(data, logger)
        pkceRequestStore := auth.NewPKCERequestStore(data, logger)
        userStore := auth.NewUserStore(data, logger)
        return auth.NewStore(data, logger, oAuthClientStore, oAuthRequestStore, oidcSessionStore, pkceRequestStore, userStore)
}</span>

func createCasbin(data *kivik.Client, logger log.Logger) (*casbin.Enforcer, *CasbinWatcher, error) <span class="cov0" title="0">{
        box := rice.MustFindBox("../../conf/")
        m, err := model.NewModelFromString(box.MustString("casbin_model.conf"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">adapter, err := NewCasbinAdapter(data, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">watcher := NewCasbinWatcher(data, logger)

        e, err := casbin.NewEnforcer(m, adapter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">e.EnableLog(false)
        e.EnableAutoSave(true)

        err = e.SetWatcher(watcher)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return e, watcher, nil</span>
}

func migrateAclDb(ctx context.Context, logger log.Logger, client *kivik.Client) error <span class="cov0" title="0">{
        if err := couch.InitDb(ctx, logger, client, couch.AclDB); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func migrateOAuthDb(ctx context.Context, logger log.Logger, client *kivik.Client) error <span class="cov0" title="0">{
        if err := couch.InitDb(ctx, logger, client, couch.OAuthDB); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := couch.InitIndex(ctx, logger, client, couch.OAuthDB, "kind_index", couch.Query{
                "fields": []string{"kind"},
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := couch.InitIndex(ctx, logger, client, couch.OAuthDB, "oauth_reqs_index", couch.Query{
                "fields": []string{"req.id"},
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := couch.InitIndex(ctx, logger, client, couch.OAuthDB, "oauth_sigs_index", couch.Query{
                "fields": []string{"sig"},
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := couch.InitIndex(ctx, logger, client, couch.OAuthDB, "openid_reqs_index", couch.Query{
                "fields": []string{"auth_code"},
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func migrateUsersDb(ctx context.Context, logger log.Logger, client *kivik.Client) error <span class="cov0" title="0">{
        if err := couch.InitDb(ctx, logger, client, couch.UsersDB); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "context"

        "github.com/casbin/casbin/v2/model"
        "github.com/casbin/casbin/v2/persist"
        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
)

type CasbinRule struct {
        Id    string `json:"_id,omitempty"`
        Rev   string `json:"_rev,omitempty"`
        PType string `json:"PType,omitempty"`
        V0    string `json:"V0,omitempty"`
        V1    string `json:"V1,omitempty"`
        V2    string `json:"V2,omitempty"`
        V3    string `json:"V3,omitempty"`
        V4    string `json:"V4,omitempty"`
        V5    string `json:"V5,omitempty"`
}

type CasbinAdapter struct {
        logger log.Logger
        data   *kivik.Client
        policy []CasbinRule
}

func NewCasbinAdapter(data *kivik.Client, logger log.Logger) (*CasbinAdapter, error) <span class="cov0" title="0">{
        return &amp;CasbinAdapter{
                data:   data,
                logger: logger,
        }, nil
}</span>

func (a *CasbinAdapter) LoadPolicy(model model.Model) error <span class="cov0" title="0">{
        err := a.loadFromDatabase()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, line := range a.policy </span><span class="cov0" title="0">{
                loadPolicyLine(line, model)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (a *CasbinAdapter) SavePolicy(model model.Model) error <span class="cov0" title="0">{
        err := a.loadFromDatabase()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        err = a.data.DestroyDB(ctx, couch.AclDB)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = a.data.CreateDB(ctx, couch.AclDB)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">a.policy = []CasbinRule{}
        var lines []CasbinRule
        for pType, ast := range model["p"] </span><span class="cov0" title="0">{
                for _, rule := range ast.Policy </span><span class="cov0" title="0">{
                        line := savePolicyLine(pType, rule)
                        lines = append(lines, line)
                }</span>
        }

        <span class="cov0" title="0">for pType, ast := range model["g"] </span><span class="cov0" title="0">{
                for _, rule := range ast.Policy </span><span class="cov0" title="0">{
                        line := savePolicyLine(pType, rule)
                        lines = append(lines, line)
                }</span>
        }

        <span class="cov0" title="0">a.policy = lines
        err = a.saveToDatabase()
        return err</span>
}

func (a *CasbinAdapter) AddPolicy(sec string, ptype string, rule []string) error <span class="cov0" title="0">{
        a.logger.Infof("adding new policy sec: %s, ptype: %s, rule: %v", sec, ptype, rule)
        ctx := context.Background()
        line := savePolicyLine(ptype, rule)
        a.logger.Debugf("%+v", line)
        db := a.data.DB(ctx, couch.AclDB)
        _, err := db.Put(ctx, line.Id, line)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return a.loadFromDatabase()</span>
}

func (a *CasbinAdapter) RemovePolicy(sec string, ptype string, rule []string) error <span class="cov0" title="0">{
        line := savePolicyLine(ptype, rule)
        err := a.deleteLineFromDatabase(line)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return a.loadFromDatabase()</span>
}

func (a *CasbinAdapter) RemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) error <span class="cov0" title="0">{
        line := CasbinRule{PType: ptype}

        idx := fieldIndex + len(fieldValues)
        if fieldIndex &lt;= 0 &amp;&amp; idx &gt; 0 </span><span class="cov0" title="0">{
                line.V0 = fieldValues[0-fieldIndex]
        }</span>
        <span class="cov0" title="0">if fieldIndex &lt;= 1 &amp;&amp; idx &gt; 1 </span><span class="cov0" title="0">{
                line.V1 = fieldValues[1-fieldIndex]
        }</span>
        <span class="cov0" title="0">if fieldIndex &lt;= 2 &amp;&amp; idx &gt; 2 </span><span class="cov0" title="0">{
                line.V2 = fieldValues[2-fieldIndex]
        }</span>
        <span class="cov0" title="0">if fieldIndex &lt;= 3 &amp;&amp; idx &gt; 3 </span><span class="cov0" title="0">{
                line.V3 = fieldValues[3-fieldIndex]
        }</span>
        <span class="cov0" title="0">if fieldIndex &lt;= 4 &amp;&amp; idx &gt; 4 </span><span class="cov0" title="0">{
                line.V4 = fieldValues[4-fieldIndex]
        }</span>
        <span class="cov0" title="0">if fieldIndex &lt;= 5 &amp;&amp; idx &gt; 5 </span><span class="cov0" title="0">{
                line.V5 = fieldValues[5-fieldIndex]
        }</span>

        <span class="cov0" title="0">err := a.deleteLineFromDatabase(line)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return a.loadFromDatabase()</span>
}

func (a *CasbinAdapter) loadFromDatabase() error <span class="cov0" title="0">{
        a.logger.Debug("loading rules from database")
        var policy []CasbinRule
        ctx := context.Background()
        db := a.data.DB(ctx, couch.AclDB)
        rows, err := db.AllDocs(ctx, kivik.Options{
                "include_docs": true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">a.logger.Debug("fetched rules from database. Attempting to load")
        for rows.Next() </span><span class="cov0" title="0">{
                var line CasbinRule
                if err := rows.ScanDoc(&amp;line); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">a.logger.Debugf("loaded rule %+v", line)
                policy = append(policy, line)</span>
        }

        <span class="cov0" title="0">a.policy = policy
        return nil</span>
}

func (a *CasbinAdapter) saveToDatabase() error <span class="cov0" title="0">{
        ctx := context.Background()
        db := a.data.DB(ctx, couch.AclDB)
        for i, line := range a.policy </span><span class="cov0" title="0">{
                if line.Id == "" </span><span class="cov0" title="0">{
                        line.Id = lineToText(line)
                }</span>

                <span class="cov0" title="0">rev, err := db.Put(ctx, line.Id, line)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">a.policy[i].Rev = rev</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func loadPolicyLine(line CasbinRule, model model.Model) <span class="cov0" title="0">{
        lineText := lineToText(line)
        persist.LoadPolicyLine(lineText, model)
}</span>

func savePolicyLine(ptype string, rule []string) CasbinRule <span class="cov0" title="0">{
        line := CasbinRule{}

        line.PType = ptype
        if len(rule) &gt; 0 </span><span class="cov0" title="0">{
                line.V0 = rule[0]
        }</span>
        <span class="cov0" title="0">if len(rule) &gt; 1 </span><span class="cov0" title="0">{
                line.V1 = rule[1]
        }</span>
        <span class="cov0" title="0">if len(rule) &gt; 2 </span><span class="cov0" title="0">{
                line.V2 = rule[2]
        }</span>
        <span class="cov0" title="0">if len(rule) &gt; 3 </span><span class="cov0" title="0">{
                line.V3 = rule[3]
        }</span>
        <span class="cov0" title="0">if len(rule) &gt; 4 </span><span class="cov0" title="0">{
                line.V4 = rule[4]
        }</span>
        <span class="cov0" title="0">if len(rule) &gt; 5 </span><span class="cov0" title="0">{
                line.V5 = rule[5]
        }</span>

        <span class="cov0" title="0">line.Id = lineToText(line)

        return line</span>
}

func lineToText(line CasbinRule) string <span class="cov0" title="0">{
        lineText := line.PType
        if line.V0 != "" </span><span class="cov0" title="0">{
                lineText += ", " + line.V0
        }</span>
        <span class="cov0" title="0">if line.V1 != "" </span><span class="cov0" title="0">{
                lineText += ", " + line.V1
        }</span>
        <span class="cov0" title="0">if line.V2 != "" </span><span class="cov0" title="0">{
                lineText += ", " + line.V2
        }</span>
        <span class="cov0" title="0">if line.V3 != "" </span><span class="cov0" title="0">{
                lineText += ", " + line.V3
        }</span>
        <span class="cov0" title="0">if line.V4 != "" </span><span class="cov0" title="0">{
                lineText += ", " + line.V4
        }</span>
        <span class="cov0" title="0">if line.V5 != "" </span><span class="cov0" title="0">{
                lineText += ", " + line.V5
        }</span>
        <span class="cov0" title="0">return lineText</span>
}

func (a *CasbinAdapter) deleteLineFromDatabase(line CasbinRule) error <span class="cov0" title="0">{
        ctx := context.Background()
        if line.Id == "" </span><span class="cov0" title="0">{
                line.Id = lineToText(line)
        }</span>

        <span class="cov0" title="0">db := a.data.DB(ctx, couch.AclDB)
        _, rev, err := db.GetMeta(ctx, line.Id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = db.Delete(ctx, line.Id, rev)
        return err</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "context"
        "runtime"
        "sync"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/pkg/log"
        "github.com/go-kivik/kivik"
)

type CallbackFunc func(string)

type CasbinWatcher struct {
        logger   log.Logger
        data     *kivik.Client
        callback CallbackFunc
        ch       *kivik.Changes
        once     sync.Once
}

func NewCasbinWatcher(data *kivik.Client, logger log.Logger) *CasbinWatcher <span class="cov0" title="0">{
        w := &amp;CasbinWatcher{
                logger: logger,
                data:   data,
        }

        return w
}</span>

// SetUpdateCallback sets the callback function that the watcher will call
// when the policy in DB has been changed by other instances.
// A classic callback is Enforcer.LoadPolicy().
func (w *CasbinWatcher) SetUpdateCallback(cb func(string)) error <span class="cov0" title="0">{
        w.callback = cb
        return nil
}</span>

// Update calls the update callback of other instances to synchronize their policy.
// It is usually called after changing the policy in DB, like Enforcer.SavePolicy(),
// Enforcer.AddPolicy(), Enforcer.RemovePolicy(), etc.
func (w *CasbinWatcher) Update() error <span class="cov0" title="0">{
        // noop because Couch provides the update for us via the Changes feed
        return nil
}</span>

// Close stops and releases the watcher, the callback function will not be called any more.
func (w *CasbinWatcher) Close() <span class="cov0" title="0">{
        finalizer(w)
}</span>

func (w *CasbinWatcher) Start(ctx context.Context) error <span class="cov0" title="0">{
        db := w.data.DB(ctx, couch.AclDB)
        runtime.SetFinalizer(w, finalizer)

        go func() </span><span class="cov0" title="0">{
                w.logger.Info("started ACL watcher")
                for </span><span class="cov0" title="0">{
                        ch, err := db.Changes(ctx, kivik.Options{
                                "feed": "continuous",
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                w.logger.Error(err)
                                return
                        }</span>

                        <span class="cov0" title="0">w.ch = ch

                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                w.logger.Info("shutting down ACL watcher")
                                w.logger.Error(ctx.Err())
                                return</span>
                        default:<span class="cov0" title="0">
                                for ch.Next() </span><span class="cov0" title="0">{
                                        if ch.ID() != "" </span><span class="cov0" title="0">{
                                                w.logger.Debugf("received change from feed. id: %s", ch.ID())
                                                w.callback(ch.ID())
                                        }</span>
                                }

                                <span class="cov0" title="0">if ch.Err() != nil </span><span class="cov0" title="0">{
                                        w.logger.Warnf("stopping watcher. Reason: %s", ch.Err().Error())
                                        return
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

func finalizer(w *CasbinWatcher) <span class="cov0" title="0">{
        w.once.Do(func() </span><span class="cov0" title="0">{
                w.logger.Warn("finalizing ACL watcher")
                if err := w.ch.Close(); err != nil </span><span class="cov0" title="0">{
                        w.logger.Error(err)
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package auth

import (
        "net/http"
        "strings"

        "github.com/enseadaio/enseada/internal/middleware"

        "github.com/casbin/casbin/v2"
        "github.com/enseadaio/enseada/internal/auth"
        authv1beta1api "github.com/enseadaio/enseada/internal/auth/v1beta1"
        "github.com/enseadaio/enseada/internal/utils"
        authv1beta1 "github.com/enseadaio/enseada/rpc/auth/v1beta1"
        session "github.com/ipfans/echo-session"
        "github.com/labstack/echo"
        "github.com/labstack/gommon/random"
        "github.com/ory/fosite"
        "github.com/pkg/errors"
)

func mountRoutes(e *echo.Echo, s *auth.Store, op fosite.OAuth2Provider, enf *casbin.Enforcer, sm echo.MiddlewareFunc) <span class="cov0" title="0">{
        e.Use(echo.WrapMiddleware(middleware.AuthorizationHeader(s.Logger, s, op)))

        g := e.Group("/oauth")
        g.Use(sm)
        g.GET("/authorize", authorizationPage())
        g.POST("/authorize", authorize(op, s))
        g.POST("/token", token(op, s))
        g.POST("/token/introspect", introspect(op))

        acl := authv1beta1api.NewAclAPI(s.Logger, enf)
        aclhandler := authv1beta1.NewAclAPIServer(acl, nil)
        e.Any(aclhandler.PathPrefix()+"*", echo.WrapHandler(aclhandler))

        oclients := authv1beta1api.NewOAuthClientsAPI(s.Logger, enf, s)
        oclientshandler := authv1beta1.NewOAuthClientsAPIServer(oclients, nil)
        e.Any(oclientshandler.PathPrefix()+"*", echo.WrapHandler(oclientshandler))

        users := authv1beta1api.NewUsersAPI(s.Logger, enf, s)
        usershandler := authv1beta1.NewUsersAPIServer(users, nil)
        e.Any(usershandler.PathPrefix()+"*", echo.WrapHandler(usershandler))
}</span>

func authorizationPage() echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                s := session.Default(c)
                e := s.Flashes("errors")
                params := echo.Map{
                        "ClientID":     utils.QueryWithDefault(c, "client_id", ""),
                        "RedirectURI":  utils.QueryWithDefault(c, "redirect_uri", ""),
                        "State":        utils.QueryWithDefault(c, "state", random.String(32)),
                        "Scope":        utils.QueryWithDefault(c, "scope", ""),
                        "Audience":     utils.QueryWithDefault(c, "audience", ""),
                        "ResponseType": utils.QueryWithDefault(c, "response_type", "code"),
                }
                if len(e) &gt; 0 </span><span class="cov0" title="0">{
                        params["Errors"] = e
                }</span>

                <span class="cov0" title="0">return c.Render(http.StatusOK, "login", params)</span>
        }
}

func authorize(oauth fosite.OAuth2Provider, store *auth.Store) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                req := c.Request()
                resw := c.Response()
                ctx := req.Context()

                ar, err := oauth.NewAuthorizeRequest(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        c.Logger().Error(err)
                        oauth.WriteAuthorizeError(resw, ar, err)
                        return nil
                }</span>

                <span class="cov0" title="0">for _, scope := range ar.GetRequestedScopes() </span><span class="cov0" title="0">{
                        ar.GrantScope(scope)
                }</span>

                <span class="cov0" title="0">username := strings.TrimSpace(req.FormValue("username"))
                password := strings.TrimSpace(req.FormValue("password"))

                err = store.Authenticate(ctx, username, password)
                if err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(req.Header.Get("accept"), "html") </span><span class="cov0" title="0">{
                                s := session.Default(c)
                                s.AddFlash("Invalid username of password", "errors")
                                if err := s.Save(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">return c.Redirect(http.StatusSeeOther, c.Request().Header.Get("Referer"))</span>
                        }
                        <span class="cov0" title="0">oauth.WriteAuthorizeError(resw, ar, fosite.ErrAccessDenied)
                        return nil</span>
                }

                <span class="cov0" title="0">u, err := store.GetUser(ctx, username)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">os := auth.NewSession(u)
                res, err := oauth.NewAuthorizeResponse(ctx, ar, os)
                if err != nil </span><span class="cov0" title="0">{
                        c.Logger().Error(err)
                        oauth.WriteAuthorizeError(resw, ar, err)
                        return nil
                }</span>

                <span class="cov0" title="0">oauth.WriteAuthorizeResponse(resw, ar, res)
                return nil</span>
        }
}

func token(oauth fosite.OAuth2Provider, store *auth.Store) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                req := c.Request()
                resw := c.Response()
                ctx := req.Context()

                os := auth.NewSession(nil)
                c.Logger().Debug(req)
                ar, err := oauth.NewAccessRequest(ctx, req, os)
                if err != nil </span><span class="cov0" title="0">{
                        rfce := errors.Cause(err).(*fosite.RFC6749Error)
                        if strings.Contains(rfce.Debug, "password") </span><span class="cov0" title="0">{
                                c.Logger().Error("authentication failed")
                                oauth.WriteAccessError(resw, ar, fosite.ErrAccessDenied)
                                return nil

                        }</span>
                        <span class="cov0" title="0">c.Logger().Error(err)
                        oauth.WriteAccessError(resw, ar, err)
                        return nil</span>
                }

                <span class="cov0" title="0">for _, scope := range ar.GetRequestedScopes() </span><span class="cov0" title="0">{
                        if fosite.WildcardScopeStrategy(ar.GetClient().GetScopes(), scope) </span><span class="cov0" title="0">{
                                ar.GrantScope(scope)
                        }</span>
                }

                // If this is a password grant, populate the session.
                <span class="cov0" title="0">if ar.GetGrantTypes().Exact("password") </span><span class="cov0" title="0">{
                        username := strings.TrimSpace(req.FormValue("username"))
                        u, err := store.GetUser(ctx, username)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">ar.SetSession(auth.NewSession(u))</span>
                }

                <span class="cov0" title="0">res, err := oauth.NewAccessResponse(ctx, ar)
                if err != nil </span><span class="cov0" title="0">{
                        c.Logger().Error(err)
                        oauth.WriteAccessError(resw, ar, err)
                        return nil
                }</span>

                <span class="cov0" title="0">oauth.WriteAccessResponse(resw, ar, res)
                return nil</span>
        }
}

func introspect(oauth fosite.OAuth2Provider) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                ctx := c.Request().Context()
                req := c.Request()
                resw := c.Response().Writer
                os := auth.NewSession(nil)

                ir, err := oauth.NewIntrospectionRequest(ctx, req, os)
                if err != nil </span><span class="cov0" title="0">{
                        c.Logger().Error(err)
                        oauth.WriteIntrospectionError(resw, err)
                        return nil
                }</span>

                <span class="cov0" title="0">oauth.WriteIntrospectionResponse(resw, ir)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package http

import (
        "context"

        "github.com/enseadaio/enseada/pkg/log"

        "github.com/enseadaio/enseada/internal/middleware"
        "github.com/labstack/echo"
        goauth "golang.org/x/oauth2"
)

func Boot(_ context.Context, logger log.Logger, oc *goauth.Config, skb []byte) (*echo.Echo, error) <span class="cov0" title="0">{
        e := createEchoServer(logger)

        mountHealthCheck(e)
        mountUI(e, oc, middleware.Session(skb))
        return e, nil
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package http

import (
        "encoding/json"
        "io"
        "io/ioutil"
        "net/http"

        "github.com/enseadaio/enseada/pkg/log"

        "github.com/enseadaio/enseada/internal/utils"
        "github.com/labstack/echo"
        "github.com/labstack/echo/middleware"
        elog "github.com/labstack/gommon/log"
)

func createEchoServer(l log.Logger) *echo.Echo <span class="cov0" title="0">{
        e := echo.New()

        e.Logger = &amp;EchoLogger{
                Logger: l,
                pfx:    "echo",
        }
        e.HideBanner = true
        e.HTTPErrorHandler = func(err error, c echo.Context) </span><span class="cov0" title="0">{
                e := c.JSON(http.StatusInternalServerError, utils.HTTPError(http.StatusInternalServerError, err.Error()))
                if e != nil </span><span class="cov0" title="0">{
                        c.Logger().Error(e)
                }</span>
        }

        <span class="cov0" title="0">e.Renderer = NewGoViewRenderer()

        e.Use(middleware.Recover())
        e.Use(middleware.CORS())
        e.Use(middleware.RequestID())
        e.Use(middleware.Logger())
        e.Use(middleware.GzipWithConfig(middleware.GzipConfig{
                Level: 5,
        }))
        e.Pre(middleware.RemoveTrailingSlashWithConfig(
                middleware.TrailingSlashConfig{
                        RedirectCode: http.StatusMovedPermanently,
                }))

        return e</span>
}

type EchoLogger struct {
        log.Logger
        pfx string
}

func (e *EchoLogger) Output() io.Writer <span class="cov0" title="0">{
        return ioutil.Discard // not supported ATM
}</span>

func (e *EchoLogger) SetOutput(w io.Writer) {<span class="cov0" title="0">
        // not supported ATM
}</span>

func (e *EchoLogger) Prefix() string <span class="cov0" title="0">{
        return e.pfx
}</span>

func (e *EchoLogger) SetPrefix(p string) <span class="cov0" title="0">{
        e = e.Child(p).(*EchoLogger)
        e.pfx = p
}</span>

func (e *EchoLogger) Level() elog.Lvl <span class="cov0" title="0">{
        switch e.GetLevel() </span>{
        case log.TRACE:<span class="cov0" title="0">
                return elog.DEBUG</span>
        case log.DEBUG:<span class="cov0" title="0">
                return elog.DEBUG</span>
        case log.INFO:<span class="cov0" title="0">
                return elog.INFO</span>
        case log.WARN:<span class="cov0" title="0">
                return elog.WARN</span>
        case log.ERROR:<span class="cov0" title="0">
                return elog.ERROR</span>
        case log.FATAL:<span class="cov0" title="0">
                return elog.ERROR</span>
        default:<span class="cov0" title="0">
                return elog.INFO</span>
        }
}

func (e *EchoLogger) SetLevel(v elog.Lvl) {<span class="cov0" title="0">
        // not supported ATM
}</span>

func (e *EchoLogger) SetHeader(h string) {<span class="cov0" title="0">
        // not supported ATM
}</span>

func (e *EchoLogger) Print(i ...interface{}) <span class="cov0" title="0">{
        e.Trace(i)
}</span>

func (e *EchoLogger) Printf(format string, args ...interface{}) <span class="cov0" title="0">{
        e.Tracef(format, args)
}</span>

func (e *EchoLogger) Printj(j elog.JSON) <span class="cov0" title="0">{
        b, err := json.Marshal(j)
        if err != nil </span><span class="cov0" title="0">{
                e.Panic(err)
        }</span>
        <span class="cov0" title="0">e.Trace(b)</span>
}

func (e *EchoLogger) Debugj(j elog.JSON) <span class="cov0" title="0">{
        b, err := json.Marshal(j)
        if err != nil </span><span class="cov0" title="0">{
                e.Panic(err)
        }</span>
        <span class="cov0" title="0">e.Debug(b)</span>
}

func (e *EchoLogger) Infoj(j elog.JSON) <span class="cov0" title="0">{
        b, err := json.Marshal(j)
        if err != nil </span><span class="cov0" title="0">{
                e.Panic(err)
        }</span>
        <span class="cov0" title="0">e.Info(b)</span>
}

func (e *EchoLogger) Warnj(j elog.JSON) <span class="cov0" title="0">{
        b, err := json.Marshal(j)
        if err != nil </span><span class="cov0" title="0">{
                e.Panic(err)
        }</span>
        <span class="cov0" title="0">e.Warn(b)</span>
}

func (e *EchoLogger) Errorj(j elog.JSON) <span class="cov0" title="0">{
        b, err := json.Marshal(j)
        if err != nil </span><span class="cov0" title="0">{
                e.Panic(err)
        }</span>
        <span class="cov0" title="0">e.Error(b)</span>
}

func (e *EchoLogger) Fatalj(j elog.JSON) <span class="cov0" title="0">{
        b, err := json.Marshal(j)
        if err != nil </span><span class="cov0" title="0">{
                e.Panic(err)
        }</span>
        <span class="cov0" title="0">e.Fatal(b)</span>
}

func (e *EchoLogger) Panicj(j elog.JSON) <span class="cov0" title="0">{
        b, err := json.Marshal(j)
        if err != nil </span><span class="cov0" title="0">{
                e.Panic(err)
        }</span>
        <span class="cov0" title="0">e.Panic(b)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package http

import (
        "net/http"

        "github.com/labstack/echo"
)

type HealthCheckResponse struct {
        Status   string `json:"status"`
        Protocol string `json:"protocol"`
        Host     string `json:"host"`
        Remote   string `json:"remote"`
        Method   string `json:"method"`
        Path     string `json:"path"`
}

func mountHealthCheck(e *echo.Echo) <span class="cov0" title="0">{
        e.GET("/health", func(c echo.Context) error </span><span class="cov0" title="0">{
                req := c.Request()
                res := HealthCheckResponse{
                        Status:   "UP",
                        Protocol: req.Proto,
                        Host:     req.Host,
                        Remote:   req.RemoteAddr,
                        Method:   req.Method,
                        Path:     req.URL.Path,
                }
                return c.JSON(http.StatusOK, res)
        }</span>)
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package http

import (
        "html/template"
        "io"

        rice "github.com/GeertJohan/go.rice"
        "github.com/foolin/goview"
        "github.com/foolin/goview/supports/gorice"
        "github.com/labstack/echo"
)

type TemplateRenderer struct {
        *goview.ViewEngine
}

func NewGoViewRenderer() *TemplateRenderer <span class="cov0" title="0">{
        box := rice.MustFindBox("../../web/templates")
        gv := gorice.NewWithConfig(box, goview.Config{
                Root:         "views",
                Extension:    ".html",
                Master:       "layouts/master",
                Partials:     []string{"partials/navbar"},
                Funcs:        make(template.FuncMap),
                DisableCache: false,
                Delims:       goview.Delims{Left: "{{", Right: "}}"},
        })
        return &amp;TemplateRenderer{ViewEngine: gv}

}</span>

func (t *TemplateRenderer) Render(w io.Writer, name string, data interface{}, c echo.Context) error <span class="cov0" title="0">{
        return t.ViewEngine.RenderWriter(w, name, data)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package http

import (
        "encoding/json"
        "io/ioutil"
        "net/http"
        "net/url"
        "strings"

        rice "github.com/GeertJohan/go.rice"
        "github.com/enseadaio/enseada/internal/auth"
        session "github.com/ipfans/echo-session"
        "github.com/labstack/echo"
        "github.com/labstack/gommon/random"
        goauth "golang.org/x/oauth2"
)

func mountUI(e *echo.Echo, oc *goauth.Config, sm echo.MiddlewareFunc) <span class="cov0" title="0">{
        e.GET("/", root)

        staticHandler := http.FileServer(rice.MustFindBox("../../web/static").HTTPBox())
        e.GET("/static/*", echo.WrapHandler(http.StripPrefix("/static/", staticHandler)))

        assetHandler := http.FileServer(rice.MustFindBox("../../web/assets").HTTPBox())
        e.GET("/assets/*", echo.WrapHandler(http.StripPrefix("/assets/", assetHandler)))

        u := e.Group("/ui")
        u.Use(sm)
        u.GET("", home(oc))
        u.GET("/profile", profile(oc))
        u.GET("/repositories", repos(oc))
        u.GET("/callback", callback(oc))
}</span>

func home(oc *goauth.Config) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                return renderPage(c, "index", oc, echo.Map{})
        }</span>
}

func repos(oc *goauth.Config) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                return renderPage(c, "repos", oc, echo.Map{})
        }</span>
}

func profile(oc *goauth.Config) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                s := session.Default(c)
                id := s.Get("current_user_id")
                if id == nil </span><span class="cov0" title="0">{
                        return c.Redirect(http.StatusSeeOther, oc.AuthCodeURL(random.String(32)))
                }</span>

                <span class="cov0" title="0">return renderPage(c, "profile", oc, echo.Map{})</span>
        }
}

func callback(oc *goauth.Config) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                code := c.QueryParam("code")
                ctx := c.Request().Context()
                c.Logger().Info(code)
                t, err := oc.Exchange(ctx, code)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">cl := &amp;http.Client{}
                v := url.Values{}
                v.Set("token", t.AccessToken)
                v.Set("token_type_hint", "access_token")
                req, err := http.NewRequest("POST", oc.Endpoint.TokenURL+"/introspect", strings.NewReader(v.Encode()))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">req.SetBasicAuth(oc.ClientID, oc.ClientSecret)
                req.Header.Set("content-type", "application/x-www-form-urlencoded")
                req.Header.Add("Accept-Encoding", "identity")
                res, err := cl.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">defer res.Body.Close()

                b, err := ioutil.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var body map[string]interface{}
                err = json.Unmarshal(b, &amp;body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">s := session.Default(c)
                if body["active"] == true </span><span class="cov0" title="0">{
                        s.Set("access_token", t.AccessToken)
                        s.Set("refresh_token", t.RefreshToken)
                        s.Set("current_user_id", body["sub"].(string))
                        s.Set("current_user_name", body["username"].(string))
                        err = s.Save()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        s.Clear()
                }</span>

                <span class="cov0" title="0">return c.Redirect(http.StatusTemporaryRedirect, "/ui")</span>
        }
}

func root(c echo.Context) error <span class="cov0" title="0">{
        acc := c.Request().Header.Get("accept")

        if strings.Contains(acc, "html") </span><span class="cov0" title="0">{
                return c.Redirect(http.StatusMovedPermanently, "/ui")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusNotFound, echo.Map{
                "error":   "not_found",
                "message": "NotFound",
        })</span>
}

func renderPage(c echo.Context, name string, oc *goauth.Config, data echo.Map) error <span class="cov0" title="0">{
        pusher, ok := c.Response().Writer.(http.Pusher)
        if ok </span><span class="cov0" title="0">{
                if err := pusher.Push("/static/main.css", nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := pusher.Push("/static/runtime.js", nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := pusher.Push("/static/app.js", nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">s := session.Default(c)
        addCurrentUser(s, data)
        data["LoginURL"] = oc.AuthCodeURL(random.String(32))
        return c.Render(http.StatusOK, name, data)</span>
}

func addCurrentUser(s session.Session, params echo.Map) <span class="cov0" title="0">{
        i := s.Get("current_user_id")
        u := s.Get("current_user_name")
        if i != nil &amp;&amp; u != nil </span><span class="cov0" title="0">{
                params["CurrentUser"] = auth.User{
                        Username: i.(string),
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package adapters

import (
        "fmt"

        "github.com/enseadaio/enseada/pkg/log"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type ZapLoggerAdapter struct {
        l   *zap.Logger
        lvl log.Level
}

func NewZapLoggerAdapter(lvl log.Level) (*ZapLoggerAdapter, error) <span class="cov8" title="1">{
        cfg := zap.NewProductionConfig()
        zlvl := new(zapcore.Level)
        err := zlvl.UnmarshalText([]byte(lvl))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cfg.Level.SetLevel(*zlvl)
        cfg.OutputPaths = []string{"stdout"}

        l, err := cfg.Build(zap.AddCallerSkip(2))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ZapLoggerAdapter{l: l, lvl: lvl}, nil</span>
}

func (z *ZapLoggerAdapter) Log(lvl log.Level, i ...interface{}) <span class="cov0" title="0">{
        defer z.l.Sync()

        var msg string
        f, ok := i[0].(string)
        if !ok || f == "" </span><span class="cov0" title="0">{
                msg = fmt.Sprint(i...)
        }</span> else<span class="cov0" title="0"> {
                msg = fmt.Sprintf(f, i[1:]...)
        }</span>

        <span class="cov0" title="0">switch lvl </span>{
        case log.TRACE:<span class="cov0" title="0">
                z.l.Debug(msg)</span>
        case log.DEBUG:<span class="cov0" title="0">
                z.l.Debug(msg)</span>
        case log.INFO:<span class="cov0" title="0">
                z.l.Info(msg)</span>
        case log.WARN:<span class="cov0" title="0">
                z.l.Warn(msg)</span>
        case log.ERROR:<span class="cov0" title="0">
                z.l.Error(msg)</span>
        case log.FATAL:<span class="cov0" title="0">
                z.l.Fatal(msg)</span>
        case log.PANIC:<span class="cov0" title="0">
                z.l.Panic(msg)</span>
        default:<span class="cov0" title="0">
                z.l.Info(msg)</span>
        }
}

func (z *ZapLoggerAdapter) Logf(lvl log.Level, msg string, params ...interface{}) <span class="cov0" title="0">{
        defer z.l.Sync()

        s := fmt.Sprintf(msg, params...)
        switch lvl </span>{
        case log.TRACE:<span class="cov0" title="0">
                z.l.Debug(s)</span>
        case log.DEBUG:<span class="cov0" title="0">
                z.l.Debug(s)</span>
        case log.INFO:<span class="cov0" title="0">
                z.l.Info(s)</span>
        case log.WARN:<span class="cov0" title="0">
                z.l.Warn(s)</span>
        case log.ERROR:<span class="cov0" title="0">
                z.l.Error(s)</span>
        case log.FATAL:<span class="cov0" title="0">
                z.l.Fatal(s)</span>
        case log.PANIC:<span class="cov0" title="0">
                z.l.Panic(s)</span>
        default:<span class="cov0" title="0">
                z.l.Info(msg)</span>
        }
}

func (z *ZapLoggerAdapter) Trace(i ...interface{}) <span class="cov0" title="0">{
        z.Log(log.TRACE, i...)
}</span>

func (z *ZapLoggerAdapter) Tracef(msg string, params ...interface{}) <span class="cov0" title="0">{
        z.Logf(log.TRACE, msg, params...)
}</span>

func (z *ZapLoggerAdapter) Debug(i ...interface{}) <span class="cov0" title="0">{
        z.Log(log.DEBUG, i...)
}</span>

func (z *ZapLoggerAdapter) Debugf(msg string, params ...interface{}) <span class="cov0" title="0">{
        z.Logf(log.DEBUG, msg, params...)
}</span>

func (z *ZapLoggerAdapter) Info(i ...interface{}) <span class="cov0" title="0">{
        z.Log(log.INFO, i...)
}</span>

func (z *ZapLoggerAdapter) Infof(msg string, params ...interface{}) <span class="cov0" title="0">{
        z.Logf(log.INFO, msg, params...)
}</span>

func (z *ZapLoggerAdapter) Warn(i ...interface{}) <span class="cov0" title="0">{
        z.Log(log.WARN, i...)
}</span>

func (z *ZapLoggerAdapter) Warnf(msg string, params ...interface{}) <span class="cov0" title="0">{
        z.Logf(log.WARN, msg, params...)
}</span>

func (z *ZapLoggerAdapter) Error(i ...interface{}) <span class="cov0" title="0">{
        z.Log(log.ERROR, i...)
}</span>

func (z *ZapLoggerAdapter) Errorf(msg string, params ...interface{}) <span class="cov0" title="0">{
        z.Logf(log.ERROR, msg, params...)
}</span>

func (z *ZapLoggerAdapter) Fatal(i ...interface{}) <span class="cov0" title="0">{
        z.Log(log.FATAL, i...)
}</span>

func (z *ZapLoggerAdapter) Fatalf(msg string, params ...interface{}) <span class="cov0" title="0">{
        z.Logf(log.FATAL, msg, params...)
}</span>

func (z *ZapLoggerAdapter) Panic(i ...interface{}) <span class="cov0" title="0">{
        z.Log(log.PANIC, i...)
}</span>

func (z *ZapLoggerAdapter) Panicf(msg string, params ...interface{}) <span class="cov0" title="0">{
        z.Logf(log.PANIC, msg, params...)
}</span>

func (z *ZapLoggerAdapter) Child(name string) log.Logger <span class="cov0" title="0">{
        l := z.l.Named(name)
        return &amp;ZapLoggerAdapter{l: l}
}</span>

func (z *ZapLoggerAdapter) WithMeta(key string, value interface{}) log.Logger <span class="cov0" title="0">{
        l := z.l.With(zap.Any(key, value))
        return &amp;ZapLoggerAdapter{l: l, lvl: z.lvl}
}</span>

func (z *ZapLoggerAdapter) GetLevel() log.Level <span class="cov0" title="0">{
        return z.lvl
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package maven

import (
        "context"

        "github.com/enseadaio/enseada/pkg/log"

        "github.com/casbin/casbin/v2"
        "github.com/chartmuseum/storage"
        "github.com/enseadaio/enseada/internal/auth"
        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/internal/maven"
        "github.com/go-kivik/kivik"
        "github.com/labstack/echo"
        "github.com/ory/fosite"
)

func Boot(ctx context.Context, logger log.Logger, e *echo.Echo, data *kivik.Client, store storage.Backend, enf *casbin.Enforcer, s *auth.Store, op fosite.OAuth2Provider) error <span class="cov0" title="0">{
        mvn := maven.New(logger, data, store)
        mountRoutes(e, mvn, s, op, enf)

        if err := couch.Transact(ctx, logger, data, migrateDB, couch.MavenDB); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func migrateDB(ctx context.Context, logger log.Logger, data *kivik.Client) error <span class="cov0" title="0">{
        if err := couch.InitDb(ctx, logger, data, couch.MavenDB); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := couch.InitIndex(ctx, logger, data, couch.MavenDB, "kind_index", map[string]interface{}{
                "fields": []string{"kind"},
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := couch.InitIndex(ctx, logger, data, couch.MavenDB, "file_index", map[string]interface{}{
                "fields": []string{"files"},
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright 2019 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package maven

import (
        "io/ioutil"
        "net/http"
        "strings"

        "github.com/enseadaio/enseada/internal/couch"
        "github.com/enseadaio/enseada/internal/ctxutils"
        "github.com/enseadaio/enseada/internal/guid"
        "github.com/enseadaio/enseada/internal/scope"
        "github.com/enseadaio/enseada/internal/utils"

        "github.com/casbin/casbin/v2"

        "github.com/enseadaio/enseada/internal/auth"
        "github.com/enseadaio/enseada/internal/maven"
        mavenv1beta1api "github.com/enseadaio/enseada/internal/maven/v1beta1"
        "github.com/enseadaio/enseada/internal/middleware"
        mavenv1beta1 "github.com/enseadaio/enseada/rpc/maven/v1beta1"
        "github.com/ory/fosite"

        "github.com/labstack/echo"
)

func mountRoutes(e *echo.Echo, m *maven.Maven, s *auth.Store, op fosite.OAuth2Provider, enf *casbin.Enforcer) <span class="cov0" title="0">{
        g := e.Group("/maven2")

        g.GET("/*", getMaven(m, enf))
        g.PUT("/*", storeMaven(m, enf))

        mvnsvc := mavenv1beta1api.Service{
                Maven:    m,
                Enforcer: enf,
        }
        mvnHandler := mavenv1beta1.NewMavenAPIServer(mvnsvc, nil)
        h := echo.WrapHandler(middleware.AuthorizationHeader(m.Logger, s, op)(mvnHandler))
        e.Any(mvnHandler.PathPrefix()+"*", h)
}</span>

func getMaven(mvn *maven.Maven, enf *casbin.Enforcer) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                ctx := c.Request().Context()

                uid, ok := ctxutils.CurrentUserID(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return c.NoContent(http.StatusUnauthorized)
                }</span>

                <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
                if !scopes.Has(scope.MavenFileRead) </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusForbidden, utils.HTTPError(http.StatusForbidden, "insufficient scopes"))
                }</span>

                <span class="cov0" title="0">path := strings.TrimPrefix(c.Request().RequestURI, "/")
                c.Logger().Infof("Loading file from %s", path)
                file, err := mvn.GetFile(ctx, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if file == nil </span><span class="cov0" title="0">{
                        c.Logger().Warnf("No file found at %s", path)
                        return c.NoContent(http.StatusNotFound)

                }</span>

                <span class="cov0" title="0">gr := guid.New(couch.MavenDB, file.Repo.ID, couch.KindRepository)
                can, err := enf.Enforce(uid, gr.String(), "read")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                        return c.NoContent(http.StatusNotFound)
                }</span>

                <span class="cov0" title="0">c.Logger().Info("File found")
                body, err := file.Content()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return c.Blob(http.StatusOK, "application/octet-stream", body)</span>
        }
}

func storeMaven(mvn *maven.Maven, enf *casbin.Enforcer) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                ctx := c.Request().Context()

                uid, ok := ctxutils.CurrentUserID(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return c.NoContent(http.StatusUnauthorized)
                }</span>

                <span class="cov0" title="0">scopes, _ := ctxutils.Scopes(ctx)
                if !scopes.Has(scope.MavenFileWrite) </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusForbidden, utils.HTTPError(http.StatusForbidden, "insufficient scopes"))
                }</span>

                <span class="cov0" title="0">path := strings.TrimPrefix(c.Request().RequestURI, "/maven2/")
                c.Logger().Infof("attempting storing Maven artifact at %s", path)
                body, err := ioutil.ReadAll(c.Request().Body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">repos, err := mvn.ListRepos(ctx, couch.Query{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var repo *maven.Repo
                for _, r := range repos </span><span class="cov0" title="0">{
                        if strings.HasPrefix(path, r.StoragePath) </span><span class="cov0" title="0">{
                                repo = r
                                break</span>
                        }
                }

                <span class="cov0" title="0">if repo == nil </span><span class="cov0" title="0">{
                        return c.NoContent(http.StatusNotFound)
                }</span>

                <span class="cov0" title="0">gr := guid.New(couch.MavenDB, repo.ID, couch.KindRepository)
                can, err := enf.Enforce(uid, gr.String(), "write")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !can </span><span class="cov0" title="0">{
                        return c.NoContent(http.StatusNotFound)
                }</span>

                <span class="cov0" title="0">file, err := mvn.PutFileInRepo(ctx, repo, path, body)
                if err != nil </span><span class="cov0" title="0">{
                        c.Logger().Error(err)
                        if err == maven.ErrorRepoNotFound </span><span class="cov0" title="0">{
                                return c.NoContent(http.StatusNotFound)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">c.Logger().Info("stored Maven artifact %s at %s", file.Filename, path)
                return c.NoContent(http.StatusCreated)</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: auth/v1beta1/acl_api.proto

package authv1beta1

import (
        fmt "fmt"
        math "math"

        proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Request body to list all available ACL rules.
type ListRulesRequest struct {
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListRulesRequest) Reset()         <span class="cov0" title="0">{ *m = ListRulesRequest{} }</span>
func (m *ListRulesRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListRulesRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListRulesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e29e90e62174e322, []int{0}
}</span>

func (m *ListRulesRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListRulesRequest.Unmarshal(m, b)
}</span>
func (m *ListRulesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListRulesRequest.Marshal(b, m, deterministic)
}</span>
func (m *ListRulesRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListRulesRequest.Merge(m, src)
}</span>
func (m *ListRulesRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListRulesRequest.Size(m)
}</span>
func (m *ListRulesRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListRulesRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListRulesRequest proto.InternalMessageInfo

// Response body with a list of all available ACL rules.
type ListRulesResponse struct {
        Rules                []*AclRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *ListRulesResponse) Reset()         <span class="cov0" title="0">{ *m = ListRulesResponse{} }</span>
func (m *ListRulesResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListRulesResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListRulesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e29e90e62174e322, []int{1}
}</span>

func (m *ListRulesResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListRulesResponse.Unmarshal(m, b)
}</span>
func (m *ListRulesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListRulesResponse.Marshal(b, m, deterministic)
}</span>
func (m *ListRulesResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListRulesResponse.Merge(m, src)
}</span>
func (m *ListRulesResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListRulesResponse.Size(m)
}</span>
func (m *ListRulesResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListRulesResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListRulesResponse proto.InternalMessageInfo

func (m *ListRulesResponse) GetRules() []*AclRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to add a new ACL rule.
type AddRuleRequest struct {
        // The rule to add. Required.
        Rule                 *AclRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AddRuleRequest) Reset()         <span class="cov0" title="0">{ *m = AddRuleRequest{} }</span>
func (m *AddRuleRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AddRuleRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AddRuleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e29e90e62174e322, []int{2}
}</span>

func (m *AddRuleRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_AddRuleRequest.Unmarshal(m, b)
}</span>
func (m *AddRuleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_AddRuleRequest.Marshal(b, m, deterministic)
}</span>
func (m *AddRuleRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AddRuleRequest.Merge(m, src)
}</span>
func (m *AddRuleRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_AddRuleRequest.Size(m)
}</span>
func (m *AddRuleRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AddRuleRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AddRuleRequest proto.InternalMessageInfo

func (m *AddRuleRequest) GetRule() *AclRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rule
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Response body with the newly added ACL rule.
type AddRuleResponse struct {
        Rule                 *AclRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AddRuleResponse) Reset()         <span class="cov0" title="0">{ *m = AddRuleResponse{} }</span>
func (m *AddRuleResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AddRuleResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AddRuleResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e29e90e62174e322, []int{3}
}</span>

func (m *AddRuleResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_AddRuleResponse.Unmarshal(m, b)
}</span>
func (m *AddRuleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_AddRuleResponse.Marshal(b, m, deterministic)
}</span>
func (m *AddRuleResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AddRuleResponse.Merge(m, src)
}</span>
func (m *AddRuleResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_AddRuleResponse.Size(m)
}</span>
func (m *AddRuleResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AddRuleResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AddRuleResponse proto.InternalMessageInfo

func (m *AddRuleResponse) GetRule() *AclRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rule
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to delete an ACL rule.
type DeleteRuleRequest struct {
        // The rule to delete. Required.
        Rule                 *AclRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRuleRequest) Reset()         <span class="cov0" title="0">{ *m = DeleteRuleRequest{} }</span>
func (m *DeleteRuleRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteRuleRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteRuleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e29e90e62174e322, []int{4}
}</span>

func (m *DeleteRuleRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRuleRequest.Unmarshal(m, b)
}</span>
func (m *DeleteRuleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRuleRequest.Marshal(b, m, deterministic)
}</span>
func (m *DeleteRuleRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteRuleRequest.Merge(m, src)
}</span>
func (m *DeleteRuleRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRuleRequest.Size(m)
}</span>
func (m *DeleteRuleRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteRuleRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteRuleRequest proto.InternalMessageInfo

func (m *DeleteRuleRequest) GetRule() *AclRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rule
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Response body with the deleted ACL rule.
type DeleteRuleResponse struct {
        Rule                 *AclRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRuleResponse) Reset()         <span class="cov0" title="0">{ *m = DeleteRuleResponse{} }</span>
func (m *DeleteRuleResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteRuleResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteRuleResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_e29e90e62174e322, []int{5}
}</span>

func (m *DeleteRuleResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRuleResponse.Unmarshal(m, b)
}</span>
func (m *DeleteRuleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRuleResponse.Marshal(b, m, deterministic)
}</span>
func (m *DeleteRuleResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteRuleResponse.Merge(m, src)
}</span>
func (m *DeleteRuleResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRuleResponse.Size(m)
}</span>
func (m *DeleteRuleResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteRuleResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteRuleResponse proto.InternalMessageInfo

func (m *DeleteRuleResponse) GetRule() *AclRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rule
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov10" title="2">{
        proto.RegisterType((*ListRulesRequest)(nil), "auth.v1beta1.ListRulesRequest")
        proto.RegisterType((*ListRulesResponse)(nil), "auth.v1beta1.ListRulesResponse")
        proto.RegisterType((*AddRuleRequest)(nil), "auth.v1beta1.AddRuleRequest")
        proto.RegisterType((*AddRuleResponse)(nil), "auth.v1beta1.AddRuleResponse")
        proto.RegisterType((*DeleteRuleRequest)(nil), "auth.v1beta1.DeleteRuleRequest")
        proto.RegisterType((*DeleteRuleResponse)(nil), "auth.v1beta1.DeleteRuleResponse")
}</span>

func init() <span class="cov10" title="2">{ proto.RegisterFile("auth/v1beta1/acl_api.proto", fileDescriptor_e29e90e62174e322) }</span>

var fileDescriptor_e29e90e62174e322 = []byte{
        // 311 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x4a, 0x2c, 0x2d, 0xc9,
        0xd0, 0x2f, 0x33, 0x4c, 0x4a, 0x2d, 0x49, 0x34, 0xd4, 0x4f, 0x4c, 0xce, 0x89, 0x4f, 0x2c, 0xc8,
        0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0xc9, 0xe9, 0x41, 0xe5, 0xa4, 0xa4, 0x31,
        0x54, 0x16, 0x95, 0xe6, 0xa4, 0x42, 0x94, 0x2a, 0x09, 0x71, 0x09, 0xf8, 0x64, 0x16, 0x97, 0x04,
        0x95, 0xe6, 0xa4, 0x16, 0x07, 0xa5, 0x16, 0x96, 0xa6, 0x16, 0x97, 0x28, 0x39, 0x70, 0x09, 0x22,
        0x89, 0x15, 0x17, 0xe4, 0xe7, 0x15, 0xa7, 0x0a, 0x69, 0x73, 0xb1, 0x82, 0xb4, 0x15, 0x4b, 0x30,
        0x2a, 0x30, 0x6b, 0x70, 0x1b, 0x89, 0xea, 0x21, 0xdb, 0xa1, 0xe7, 0x98, 0x9c, 0x03, 0x52, 0x1e,
        0x04, 0x51, 0xa3, 0x64, 0xcd, 0xc5, 0xe7, 0x98, 0x92, 0x02, 0x16, 0x81, 0x98, 0x29, 0xa4, 0xc9,
        0xc5, 0x02, 0x92, 0x92, 0x60, 0x54, 0x60, 0xc4, 0xad, 0x1b, 0xac, 0x44, 0xc9, 0x86, 0x8b, 0x1f,
        0xae, 0x19, 0x6a, 0x39, 0x09, 0xba, 0xed, 0xb8, 0x04, 0x5d, 0x52, 0x73, 0x52, 0x4b, 0x52, 0xc9,
        0xb4, 0xdd, 0x9e, 0x4b, 0x08, 0x59, 0x3f, 0xc9, 0x0e, 0x30, 0x7a, 0xcf, 0xc8, 0xc5, 0xe6, 0x98,
        0x9c, 0xe3, 0x18, 0xe0, 0x29, 0xe4, 0xc3, 0xc5, 0x09, 0x0f, 0x48, 0x21, 0x39, 0x54, 0x4d, 0xe8,
        0xa1, 0x2e, 0x25, 0x8f, 0x53, 0x1e, 0xea, 0x06, 0x37, 0x2e, 0x76, 0x68, 0xb8, 0x08, 0xc9, 0xa0,
        0x39, 0x00, 0x25, 0xac, 0xa5, 0x64, 0x71, 0xc8, 0x42, 0xcd, 0xf1, 0xe7, 0xe2, 0x42, 0xf8, 0x50,
        0x08, 0xcd, 0x5a, 0x8c, 0xb0, 0x93, 0x52, 0xc0, 0xad, 0x00, 0x62, 0xa0, 0x53, 0x24, 0x97, 0x78,
        0x66, 0xbe, 0x5e, 0x6a, 0x5e, 0x71, 0x6a, 0x62, 0x4a, 0x22, 0x8a, 0x6a, 0x27, 0x6e, 0x50, 0x48,
        0x14, 0x64, 0x06, 0x80, 0xd2, 0x5a, 0x00, 0x63, 0x14, 0x37, 0x48, 0x12, 0x2a, 0xb7, 0x88, 0x89,
        0xd9, 0x31, 0x22, 0x62, 0x15, 0x13, 0x8f, 0x23, 0x48, 0x43, 0x98, 0xa1, 0x13, 0x48, 0xf0, 0x14,
        0x84, 0x1b, 0x03, 0xe5, 0x26, 0xb1, 0x81, 0x53, 0xa9, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x18,
        0x35, 0x54, 0xf4, 0xee, 0x02, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-twirp v5.8.0, DO NOT EDIT.
// source: auth/v1beta1/acl_api.proto

/*
Package authv1beta1 is a generated twirp stub package.
This code was generated with github.com/twitchtv/twirp/protoc-gen-twirp v5.8.0.

It is generated from these files:
        auth/v1beta1/acl_api.proto
        auth/v1beta1/acl_rule.proto
        auth/v1beta1/o_auth_client.proto
        auth/v1beta1/o_auth_clients_api.proto
        auth/v1beta1/user.proto
        auth/v1beta1/users_api.proto
*/
package authv1beta1

import (
        bytes "bytes"
        strings "strings"

        context "context"

        fmt "fmt"

        ioutil "io/ioutil"

        http "net/http"

        strconv "strconv"

        jsonpb "github.com/golang/protobuf/jsonpb"

        proto "github.com/golang/protobuf/proto"

        twirp "github.com/twitchtv/twirp"

        ctxsetters "github.com/twitchtv/twirp/ctxsetters"

        // Imports only used by utility functions:

        io "io"

        json "encoding/json"

        url "net/url"
)

// ================
// AclAPI Interface
// ================

// RPC API to manage ACL and policies.
type AclAPI interface {
        // List all available ACL rules.
        ListRules(context.Context, *ListRulesRequest) (*ListRulesResponse, error)

        // Add a new ACL rules.
        AddRule(context.Context, *AddRuleRequest) (*AddRuleResponse, error)

        // Delete an ACL rules.
        DeleteRule(context.Context, *DeleteRuleRequest) (*DeleteRuleResponse, error)
}

// ======================
// AclAPI Protobuf Client
// ======================

type aclAPIProtobufClient struct {
        client HTTPClient
        urls   [3]string
}

// NewAclAPIProtobufClient creates a Protobuf client that implements the AclAPI interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewAclAPIProtobufClient(addr string, client HTTPClient) AclAPI <span class="cov0" title="0">{
        prefix := urlBase(addr) + AclAPIPathPrefix
        urls := [3]string{
                prefix + "ListRules",
                prefix + "AddRule",
                prefix + "DeleteRule",
        }
        if httpClient, ok := client.(*http.Client); ok </span><span class="cov0" title="0">{
                return &amp;aclAPIProtobufClient{
                        client: withoutRedirects(httpClient),
                        urls:   urls,
                }
        }</span>
        <span class="cov0" title="0">return &amp;aclAPIProtobufClient{
                client: client,
                urls:   urls,
        }</span>
}

func (c *aclAPIProtobufClient) ListRules(ctx context.Context, in *ListRulesRequest) (*ListRulesResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "AclAPI")
        ctx = ctxsetters.WithMethodName(ctx, "ListRules")
        out := new(ListRulesResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[0], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *aclAPIProtobufClient) AddRule(ctx context.Context, in *AddRuleRequest) (*AddRuleResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "AclAPI")
        ctx = ctxsetters.WithMethodName(ctx, "AddRule")
        out := new(AddRuleResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[1], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *aclAPIProtobufClient) DeleteRule(ctx context.Context, in *DeleteRuleRequest) (*DeleteRuleResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "AclAPI")
        ctx = ctxsetters.WithMethodName(ctx, "DeleteRule")
        out := new(DeleteRuleResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[2], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ==================
// AclAPI JSON Client
// ==================

type aclAPIJSONClient struct {
        client HTTPClient
        urls   [3]string
}

// NewAclAPIJSONClient creates a JSON client that implements the AclAPI interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewAclAPIJSONClient(addr string, client HTTPClient) AclAPI <span class="cov0" title="0">{
        prefix := urlBase(addr) + AclAPIPathPrefix
        urls := [3]string{
                prefix + "ListRules",
                prefix + "AddRule",
                prefix + "DeleteRule",
        }
        if httpClient, ok := client.(*http.Client); ok </span><span class="cov0" title="0">{
                return &amp;aclAPIJSONClient{
                        client: withoutRedirects(httpClient),
                        urls:   urls,
                }
        }</span>
        <span class="cov0" title="0">return &amp;aclAPIJSONClient{
                client: client,
                urls:   urls,
        }</span>
}

func (c *aclAPIJSONClient) ListRules(ctx context.Context, in *ListRulesRequest) (*ListRulesResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "AclAPI")
        ctx = ctxsetters.WithMethodName(ctx, "ListRules")
        out := new(ListRulesResponse)
        err := doJSONRequest(ctx, c.client, c.urls[0], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *aclAPIJSONClient) AddRule(ctx context.Context, in *AddRuleRequest) (*AddRuleResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "AclAPI")
        ctx = ctxsetters.WithMethodName(ctx, "AddRule")
        out := new(AddRuleResponse)
        err := doJSONRequest(ctx, c.client, c.urls[1], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *aclAPIJSONClient) DeleteRule(ctx context.Context, in *DeleteRuleRequest) (*DeleteRuleResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "AclAPI")
        ctx = ctxsetters.WithMethodName(ctx, "DeleteRule")
        out := new(DeleteRuleResponse)
        err := doJSONRequest(ctx, c.client, c.urls[2], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// =====================
// AclAPI Server Handler
// =====================

type aclAPIServer struct {
        AclAPI
        hooks *twirp.ServerHooks
}

func NewAclAPIServer(svc AclAPI, hooks *twirp.ServerHooks) TwirpServer <span class="cov0" title="0">{
        return &amp;aclAPIServer{
                AclAPI: svc,
                hooks:  hooks,
        }
}</span>

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *aclAPIServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) <span class="cov0" title="0">{
        writeError(ctx, resp, err, s.hooks)
}</span>

// AclAPIPathPrefix is used for all URL paths on a twirp AclAPI server.
// Requests are always: POST AclAPIPathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const AclAPIPathPrefix = "/twirp/auth.v1beta1.AclAPI/"

func (s *aclAPIServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        ctx := req.Context()
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "AclAPI")
        ctx = ctxsetters.WithResponseWriter(ctx, resp)

        var err error
        ctx, err = callRequestReceived(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">if req.Method != "POST" </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
                err = badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">switch req.URL.Path </span>{
        case "/twirp/auth.v1beta1.AclAPI/ListRules":<span class="cov0" title="0">
                s.serveListRules(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.AclAPI/AddRule":<span class="cov0" title="0">
                s.serveAddRule(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.AclAPI/DeleteRule":<span class="cov0" title="0">
                s.serveDeleteRule(ctx, resp, req)
                return</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
                err = badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, err)
                return</span>
        }
}

func (s *aclAPIServer) serveListRules(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveListRulesJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveListRulesProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *aclAPIServer) serveListRulesJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "ListRules")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(ListRulesRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *ListRulesResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.AclAPI.ListRules(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *ListRulesResponse and nil error while calling ListRules. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *aclAPIServer) serveListRulesProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "ListRules")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(ListRulesRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *ListRulesResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.AclAPI.ListRules(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *ListRulesResponse and nil error while calling ListRules. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *aclAPIServer) serveAddRule(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveAddRuleJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveAddRuleProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *aclAPIServer) serveAddRuleJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "AddRule")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(AddRuleRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *AddRuleResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.AclAPI.AddRule(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *AddRuleResponse and nil error while calling AddRule. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *aclAPIServer) serveAddRuleProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "AddRule")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(AddRuleRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *AddRuleResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.AclAPI.AddRule(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *AddRuleResponse and nil error while calling AddRule. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *aclAPIServer) serveDeleteRule(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveDeleteRuleJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveDeleteRuleProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *aclAPIServer) serveDeleteRuleJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "DeleteRule")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(DeleteRuleRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *DeleteRuleResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.AclAPI.DeleteRule(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteRuleResponse and nil error while calling DeleteRule. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *aclAPIServer) serveDeleteRuleProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "DeleteRule")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(DeleteRuleRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *DeleteRuleResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.AclAPI.DeleteRule(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteRuleResponse and nil error while calling DeleteRule. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *aclAPIServer) ServiceDescriptor() ([]byte, int) <span class="cov0" title="0">{
        return twirpFileDescriptor0, 0
}</span>

func (s *aclAPIServer) ProtocGenTwirpVersion() string <span class="cov0" title="0">{
        return "v5.8.0"
}</span>

func (s *aclAPIServer) PathPrefix() string <span class="cov0" title="0">{
        return AclAPIPathPrefix
}</span>

// =====
// Utils
// =====

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
//
// HTTPClient implementations should not follow redirects. Redirects are
// automatically disabled if *(net/http).Client is passed to client
// constructors. See the withoutRedirects function in this file for more
// details.
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// TwirpServer is the interface generated server structs will support: they're
// HTTP handlers with additional methods for accessing metadata about the
// service. Those accessors are a low-level API for building reflection tools.
// Most people can think of TwirpServers as just http.Handlers.
type TwirpServer interface {
        http.Handler
        // ServiceDescriptor returns gzipped bytes describing the .proto file that
        // this service was generated from. Once unzipped, the bytes can be
        // unmarshalled as a
        // github.com/golang/protobuf/protoc-gen-go/descriptor.FileDescriptorProto.
        //
        // The returned integer is the index of this particular service within that
        // FileDescriptorProto's 'Service' slice of ServiceDescriptorProtos. This is a
        // low-level field, expected to be used for reflection.
        ServiceDescriptor() ([]byte, int)
        // ProtocGenTwirpVersion is the semantic version string of the version of
        // twirp used to generate this file.
        ProtocGenTwirpVersion() string
        // PathPrefix returns the HTTP URL path prefix for all methods handled by this
        // service. This can be used with an HTTP mux to route twirp requests
        // alongside non-twirp requests on one HTTP listener.
        PathPrefix() string
}

// WriteError writes an HTTP response with a valid Twirp error format (code, msg, meta).
// Useful outside of the Twirp server (e.g. http middleware), but does not trigger hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func WriteError(resp http.ResponseWriter, err error) <span class="cov0" title="0">{
        writeError(context.Background(), resp, err, nil)
}</span>

// writeError writes Twirp errors in the response and triggers hooks.
func writeError(ctx context.Context, resp http.ResponseWriter, err error, hooks *twirp.ServerHooks) <span class="cov0" title="0">{
        // Non-twirp errors are wrapped as Internal (default)
        twerr, ok := err.(twirp.Error)
        if !ok </span><span class="cov0" title="0">{
                twerr = twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">statusCode := twirp.ServerHTTPStatusFromErrorCode(twerr.Code())
        ctx = ctxsetters.WithStatusCode(ctx, statusCode)
        ctx = callError(ctx, hooks, twerr)

        respBody := marshalErrorToJSON(twerr)

        resp.Header().Set("Content-Type", "application/json") // Error responses are always JSON
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBody)))
        resp.WriteHeader(statusCode) // set HTTP status code and send response

        _, writeErr := resp.Write(respBody)
        if writeErr != nil </span><span class="cov0" title="0">{
                // We have three options here. We could log the error, call the Error
                // hook, or just silently ignore the error.
                //
                // Logging is unacceptable because we don't have a user-controlled
                // logger; writing out to stderr without permission is too rude.
                //
                // Calling the Error hook would confuse users: it would mean the Error
                // hook got called twice for one request, which is likely to lead to
                // duplicated log messages and metrics, no matter how well we document
                // the behavior.
                //
                // Silently ignoring the error is our least-bad option. It's highly
                // likely that the connection is broken and the original 'err' says
                // so anyway.
                _ = writeErr
        }</span>

        <span class="cov0" title="0">callResponseSent(ctx, hooks)</span>
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string <span class="cov0" title="0">{
        // If the addr specifies a scheme, use it. If not, default to
        // http. If url.Parse fails on it, return it unchanged.
        url, err := url.Parse(addr)
        if err != nil </span><span class="cov0" title="0">{
                return addr
        }</span>
        <span class="cov0" title="0">if url.Scheme == "" </span><span class="cov0" title="0">{
                url.Scheme = "http"
        }</span>
        <span class="cov0" title="0">return url.String()</span>
}

// getCustomHTTPReqHeaders retrieves a copy of any headers that are set in
// a context through the twirp.WithHTTPRequestHeaders function.
// If there are no headers set, or if they have the wrong type, nil is returned.
func getCustomHTTPReqHeaders(ctx context.Context) http.Header <span class="cov0" title="0">{
        header, ok := twirp.HTTPRequestHeaders(ctx)
        if !ok || header == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">copied := make(http.Header)
        for k, vv := range header </span><span class="cov0" title="0">{
                if vv == nil </span><span class="cov0" title="0">{
                        copied[k] = nil
                        continue</span>
                }
                <span class="cov0" title="0">copied[k] = make([]string, len(vv))
                copy(copied[k], vv)</span>
        }
        <span class="cov0" title="0">return copied</span>
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("POST", url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if customHeader := getCustomHTTPReqHeaders(ctx); customHeader != nil </span><span class="cov0" title="0">{
                req.Header = customHeader
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", contentType)
        req.Header.Set("Content-Type", contentType)
        req.Header.Set("Twirp-Version", "v5.8.0")
        return req, nil</span>
}

// JSON serialization for errors
type twerrJSON struct {
        Code string            `json:"code"`
        Msg  string            `json:"msg"`
        Meta map[string]string `json:"meta,omitempty"`
}

// marshalErrorToJSON returns JSON from a twirp.Error, that can be used as HTTP error response body.
// If serialization fails, it will use a descriptive Internal error instead.
func marshalErrorToJSON(twerr twirp.Error) []byte <span class="cov0" title="0">{
        // make sure that msg is not too large
        msg := twerr.Msg()
        if len(msg) &gt; 1e6 </span><span class="cov0" title="0">{
                msg = msg[:1e6]
        }</span>

        <span class="cov0" title="0">tj := twerrJSON{
                Code: string(twerr.Code()),
                Msg:  msg,
                Meta: twerr.MetaMap(),
        }

        buf, err := json.Marshal(&amp;tj)
        if err != nil </span><span class="cov0" title="0">{
                buf = []byte("{\"type\": \"" + twirp.Internal + "\", \"msg\": \"There was an error but it could not be serialized into JSON\"}") // fallback
        }</span>

        <span class="cov0" title="0">return buf</span>
}

// errorFromResponse builds a twirp.Error from a non-200 HTTP response.
// If the response has a valid serialized Twirp error, then it's returned.
// If not, the response status code is used to generate a similar twirp
// error. See twirpErrorFromIntermediary for more info on intermediary errors.
func errorFromResponse(resp *http.Response) twirp.Error <span class="cov0" title="0">{
        statusCode := resp.StatusCode
        statusText := http.StatusText(statusCode)

        if isHTTPRedirect(statusCode) </span><span class="cov0" title="0">{
                // Unexpected redirect: it must be an error from an intermediary.
                // Twirp clients don't follow redirects automatically, Twirp only handles
                // POST requests, redirects should only happen on GET and HEAD requests.
                location := resp.Header.Get("Location")
                msg := fmt.Sprintf("unexpected HTTP status code %d %q received, Location=%q", statusCode, statusText, location)
                return twirpErrorFromIntermediary(statusCode, msg, location)
        }</span>

        <span class="cov0" title="0">respBodyBytes, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to read server error response body")
        }</span>
        <span class="cov0" title="0">var tj twerrJSON
        if err := json.Unmarshal(respBodyBytes, &amp;tj); err != nil </span><span class="cov0" title="0">{
                // Invalid JSON response; it must be an error from an intermediary.
                msg := fmt.Sprintf("Error from intermediary with HTTP status code %d %q", statusCode, statusText)
                return twirpErrorFromIntermediary(statusCode, msg, string(respBodyBytes))
        }</span>

        <span class="cov0" title="0">errorCode := twirp.ErrorCode(tj.Code)
        if !twirp.IsValidErrorCode(errorCode) </span><span class="cov0" title="0">{
                msg := "invalid type returned from server error response: " + tj.Code
                return twirp.InternalError(msg)
        }</span>

        <span class="cov0" title="0">twerr := twirp.NewError(errorCode, tj.Msg)
        for k, v := range tj.Meta </span><span class="cov0" title="0">{
                twerr = twerr.WithMeta(k, v)
        }</span>
        <span class="cov0" title="0">return twerr</span>
}

// twirpErrorFromIntermediary maps HTTP errors from non-twirp sources to twirp errors.
// The mapping is similar to gRPC: https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md.
// Returned twirp Errors have some additional metadata for inspection.
func twirpErrorFromIntermediary(status int, msg string, bodyOrLocation string) twirp.Error <span class="cov0" title="0">{
        var code twirp.ErrorCode
        if isHTTPRedirect(status) </span><span class="cov0" title="0">{ // 3xx
                code = twirp.Internal
        }</span> else<span class="cov0" title="0"> {
                switch status </span>{
                case 400:<span class="cov0" title="0"> // Bad Request
                        code = twirp.Internal</span>
                case 401:<span class="cov0" title="0"> // Unauthorized
                        code = twirp.Unauthenticated</span>
                case 403:<span class="cov0" title="0"> // Forbidden
                        code = twirp.PermissionDenied</span>
                case 404:<span class="cov0" title="0"> // Not Found
                        code = twirp.BadRoute</span>
                case 429, 502, 503, 504:<span class="cov0" title="0"> // Too Many Requests, Bad Gateway, Service Unavailable, Gateway Timeout
                        code = twirp.Unavailable</span>
                default:<span class="cov0" title="0"> // All other codes
                        code = twirp.Unknown</span>
                }
        }

        <span class="cov0" title="0">twerr := twirp.NewError(code, msg)
        twerr = twerr.WithMeta("http_error_from_intermediary", "true") // to easily know if this error was from intermediary
        twerr = twerr.WithMeta("status_code", strconv.Itoa(status))
        if isHTTPRedirect(status) </span><span class="cov0" title="0">{
                twerr = twerr.WithMeta("location", bodyOrLocation)
        }</span> else<span class="cov0" title="0"> {
                twerr = twerr.WithMeta("body", bodyOrLocation)
        }</span>
        <span class="cov0" title="0">return twerr</span>
}

func isHTTPRedirect(status int) bool <span class="cov0" title="0">{
        return status &gt;= 300 &amp;&amp; status &lt;= 399
}</span>

// wrapInternal wraps an error with a prefix as an Internal error.
// The original error cause is accessible by github.com/pkg/errors.Cause.
func wrapInternal(err error, prefix string) twirp.Error <span class="cov0" title="0">{
        return twirp.InternalErrorWith(&amp;wrappedError{prefix: prefix, cause: err})
}</span>

type wrappedError struct {
        prefix string
        cause  error
}

func (e *wrappedError) Cause() error  <span class="cov0" title="0">{ return e.cause }</span>
func (e *wrappedError) Error() string <span class="cov0" title="0">{ return e.prefix + ": " + e.cause.Error() }</span>

// ensurePanicResponses makes sure that rpc methods causing a panic still result in a Twirp Internal
// error response (status 500), and error hooks are properly called with the panic wrapped as an error.
// The panic is re-raised so it can be handled normally with middleware.
func ensurePanicResponses(ctx context.Context, resp http.ResponseWriter, hooks *twirp.ServerHooks) <span class="cov0" title="0">{
        if r := recover(); r != nil </span><span class="cov0" title="0">{
                // Wrap the panic as an error so it can be passed to error hooks.
                // The original error is accessible from error hooks, but not visible in the response.
                err := errFromPanic(r)
                twerr := &amp;internalWithCause{msg: "Internal service panic", cause: err}
                // Actually write the error
                writeError(ctx, resp, twerr, hooks)
                // If possible, flush the error to the wire.
                f, ok := resp.(http.Flusher)
                if ok </span><span class="cov0" title="0">{
                        f.Flush()
                }</span>

                <span class="cov0" title="0">panic(r)</span>
        }
}

// errFromPanic returns the typed error if the recovered panic is an error, otherwise formats as error.
func errFromPanic(p interface{}) error <span class="cov0" title="0">{
        if err, ok := p.(error); ok </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("panic: %v", p)</span>
}

// internalWithCause is a Twirp Internal error wrapping an original error cause, accessible
// by github.com/pkg/errors.Cause, but the original error message is not exposed on Msg().
type internalWithCause struct {
        msg   string
        cause error
}

func (e *internalWithCause) Cause() error                                <span class="cov0" title="0">{ return e.cause }</span>
func (e *internalWithCause) Error() string                               <span class="cov0" title="0">{ return e.msg + ": " + e.cause.Error() }</span>
func (e *internalWithCause) Code() twirp.ErrorCode                       <span class="cov0" title="0">{ return twirp.Internal }</span>
func (e *internalWithCause) Msg() string                                 <span class="cov0" title="0">{ return e.msg }</span>
func (e *internalWithCause) Meta(key string) string                      <span class="cov0" title="0">{ return "" }</span>
func (e *internalWithCause) MetaMap() map[string]string                  <span class="cov0" title="0">{ return nil }</span>
func (e *internalWithCause) WithMeta(key string, val string) twirp.Error <span class="cov0" title="0">{ return e }</span>

// malformedRequestError is used when the twirp server cannot unmarshal a request
func malformedRequestError(msg string) twirp.Error <span class="cov0" title="0">{
        return twirp.NewError(twirp.Malformed, msg)
}</span>

// badRouteError is used when the twirp server cannot route a request
func badRouteError(msg string, method, url string) twirp.Error <span class="cov0" title="0">{
        err := twirp.NewError(twirp.BadRoute, msg)
        err = err.WithMeta("twirp_invalid_route", method+" "+url)
        return err
}</span>

// withoutRedirects makes sure that the POST request can not be redirected.
// The standard library will, by default, redirect requests (including POSTs) if it gets a 302 or
// 303 response, and also 301s in go1.8. It redirects by making a second request, changing the
// method to GET and removing the body. This produces very confusing error messages, so instead we
// set a redirect policy that always errors. This stops Go from executing the redirect.
//
// We have to be a little careful in case the user-provided http.Client has its own CheckRedirect
// policy - if so, we'll run through that policy first.
//
// Because this requires modifying the http.Client, we make a new copy of the client and return it.
func withoutRedirects(in *http.Client) *http.Client <span class="cov0" title="0">{
        copy := *in
        copy.CheckRedirect = func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                if in.CheckRedirect != nil </span><span class="cov0" title="0">{
                        // Run the input's redirect if it exists, in case it has side effects, but ignore any error it
                        // returns, since we want to use ErrUseLastResponse.
                        err := in.CheckRedirect(req, via)
                        _ = err // Silly, but this makes sure generated code passes errcheck -blank, which some people use.
                }</span>
                <span class="cov0" title="0">return http.ErrUseLastResponse</span>
        }
        <span class="cov0" title="0">return &amp;copy</span>
}

// doProtobufRequest makes a Protobuf request to the remote Twirp service.
func doProtobufRequest(ctx context.Context, client HTTPClient, url string, in, out proto.Message) (err error) <span class="cov0" title="0">{
        reqBodyBytes, err := proto.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to marshal proto request")
        }</span>
        <span class="cov0" title="0">reqBody := bytes.NewBuffer(reqBodyBytes)
        if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">req, err := newRequest(ctx, url, reqBody, "application/protobuf")
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "could not build request")
        }</span>
        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to do request")
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                cerr := resp.Body.Close()
                if err == nil &amp;&amp; cerr != nil </span><span class="cov0" title="0">{
                        err = wrapInternal(cerr, "failed to close response body")
                }</span>
        }()

        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return errorFromResponse(resp)
        }</span>

        <span class="cov0" title="0">respBodyBytes, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to read response body")
        }</span>
        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">if err = proto.Unmarshal(respBodyBytes, out); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to unmarshal proto response")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// doJSONRequest makes a JSON request to the remote Twirp service.
func doJSONRequest(ctx context.Context, client HTTPClient, url string, in, out proto.Message) (err error) <span class="cov0" title="0">{
        reqBody := bytes.NewBuffer(nil)
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(reqBody, in); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to marshal json request")
        }</span>
        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">req, err := newRequest(ctx, url, reqBody, "application/json")
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "could not build request")
        }</span>
        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to do request")
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                cerr := resp.Body.Close()
                if err == nil &amp;&amp; cerr != nil </span><span class="cov0" title="0">{
                        err = wrapInternal(cerr, "failed to close response body")
                }</span>
        }()

        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return errorFromResponse(resp)
        }</span>

        <span class="cov0" title="0">unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(resp.Body, out); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to unmarshal json response")
        }</span>
        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Call twirp.ServerHooks.RequestReceived if the hook is available
func callRequestReceived(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) <span class="cov0" title="0">{
        if h == nil || h.RequestReceived == nil </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>
        <span class="cov0" title="0">return h.RequestReceived(ctx)</span>
}

// Call twirp.ServerHooks.RequestRouted if the hook is available
func callRequestRouted(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) <span class="cov0" title="0">{
        if h == nil || h.RequestRouted == nil </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>
        <span class="cov0" title="0">return h.RequestRouted(ctx)</span>
}

// Call twirp.ServerHooks.ResponsePrepared if the hook is available
func callResponsePrepared(ctx context.Context, h *twirp.ServerHooks) context.Context <span class="cov0" title="0">{
        if h == nil || h.ResponsePrepared == nil </span><span class="cov0" title="0">{
                return ctx
        }</span>
        <span class="cov0" title="0">return h.ResponsePrepared(ctx)</span>
}

// Call twirp.ServerHooks.ResponseSent if the hook is available
func callResponseSent(ctx context.Context, h *twirp.ServerHooks) <span class="cov0" title="0">{
        if h == nil || h.ResponseSent == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">h.ResponseSent(ctx)</span>
}

// Call twirp.ServerHooks.Error if the hook is available
func callError(ctx context.Context, h *twirp.ServerHooks, err twirp.Error) context.Context <span class="cov0" title="0">{
        if h == nil || h.Error == nil </span><span class="cov0" title="0">{
                return ctx
        }</span>
        <span class="cov0" title="0">return h.Error(ctx, err)</span>
}

var twirpFileDescriptor0 = []byte{
        // 311 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x4a, 0x2c, 0x2d, 0xc9,
        0xd0, 0x2f, 0x33, 0x4c, 0x4a, 0x2d, 0x49, 0x34, 0xd4, 0x4f, 0x4c, 0xce, 0x89, 0x4f, 0x2c, 0xc8,
        0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0xc9, 0xe9, 0x41, 0xe5, 0xa4, 0xa4, 0x31,
        0x54, 0x16, 0x95, 0xe6, 0xa4, 0x42, 0x94, 0x2a, 0x09, 0x71, 0x09, 0xf8, 0x64, 0x16, 0x97, 0x04,
        0x95, 0xe6, 0xa4, 0x16, 0x07, 0xa5, 0x16, 0x96, 0xa6, 0x16, 0x97, 0x28, 0x39, 0x70, 0x09, 0x22,
        0x89, 0x15, 0x17, 0xe4, 0xe7, 0x15, 0xa7, 0x0a, 0x69, 0x73, 0xb1, 0x82, 0xb4, 0x15, 0x4b, 0x30,
        0x2a, 0x30, 0x6b, 0x70, 0x1b, 0x89, 0xea, 0x21, 0xdb, 0xa1, 0xe7, 0x98, 0x9c, 0x03, 0x52, 0x1e,
        0x04, 0x51, 0xa3, 0x64, 0xcd, 0xc5, 0xe7, 0x98, 0x92, 0x02, 0x16, 0x81, 0x98, 0x29, 0xa4, 0xc9,
        0xc5, 0x02, 0x92, 0x92, 0x60, 0x54, 0x60, 0xc4, 0xad, 0x1b, 0xac, 0x44, 0xc9, 0x86, 0x8b, 0x1f,
        0xae, 0x19, 0x6a, 0x39, 0x09, 0xba, 0xed, 0xb8, 0x04, 0x5d, 0x52, 0x73, 0x52, 0x4b, 0x52, 0xc9,
        0xb4, 0xdd, 0x9e, 0x4b, 0x08, 0x59, 0x3f, 0xc9, 0x0e, 0x30, 0x7a, 0xcf, 0xc8, 0xc5, 0xe6, 0x98,
        0x9c, 0xe3, 0x18, 0xe0, 0x29, 0xe4, 0xc3, 0xc5, 0x09, 0x0f, 0x48, 0x21, 0x39, 0x54, 0x4d, 0xe8,
        0xa1, 0x2e, 0x25, 0x8f, 0x53, 0x1e, 0xea, 0x06, 0x37, 0x2e, 0x76, 0x68, 0xb8, 0x08, 0xc9, 0xa0,
        0x39, 0x00, 0x25, 0xac, 0xa5, 0x64, 0x71, 0xc8, 0x42, 0xcd, 0xf1, 0xe7, 0xe2, 0x42, 0xf8, 0x50,
        0x08, 0xcd, 0x5a, 0x8c, 0xb0, 0x93, 0x52, 0xc0, 0xad, 0x00, 0x62, 0xa0, 0x53, 0x24, 0x97, 0x78,
        0x66, 0xbe, 0x5e, 0x6a, 0x5e, 0x71, 0x6a, 0x62, 0x4a, 0x22, 0x8a, 0x6a, 0x27, 0x6e, 0x50, 0x48,
        0x14, 0x64, 0x06, 0x80, 0xd2, 0x5a, 0x00, 0x63, 0x14, 0x37, 0x48, 0x12, 0x2a, 0xb7, 0x88, 0x89,
        0xd9, 0x31, 0x22, 0x62, 0x15, 0x13, 0x8f, 0x23, 0x48, 0x43, 0x98, 0xa1, 0x13, 0x48, 0xf0, 0x14,
        0x84, 0x1b, 0x03, 0xe5, 0x26, 0xb1, 0x81, 0x53, 0xa9, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x18,
        0x35, 0x54, 0xf4, 0xee, 0x02, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: auth/v1beta1/acl_rule.proto

package authv1beta1

import (
        fmt "fmt"
        math "math"

        proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Single ACL rule.
type AclRule struct {
        // The subject of the rule. Required.
        Sub string `protobuf:"bytes,1,opt,name=sub,proto3" json:"sub,omitempty"`
        // The subject of the rule. Required. Must be a valid Enseada GUID.
        Obj string `protobuf:"bytes,2,opt,name=obj,proto3" json:"obj,omitempty"`
        // The action of the rule. Required.
        Act                  string   `protobuf:"bytes,3,opt,name=act,proto3" json:"act,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AclRule) Reset()         <span class="cov0" title="0">{ *m = AclRule{} }</span>
func (m *AclRule) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AclRule) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AclRule) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_53927126401a53e9, []int{0}
}</span>

func (m *AclRule) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_AclRule.Unmarshal(m, b)
}</span>
func (m *AclRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_AclRule.Marshal(b, m, deterministic)
}</span>
func (m *AclRule) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AclRule.Merge(m, src)
}</span>
func (m *AclRule) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_AclRule.Size(m)
}</span>
func (m *AclRule) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AclRule.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AclRule proto.InternalMessageInfo

func (m *AclRule) GetSub() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Sub
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AclRule) GetObj() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Obj
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AclRule) GetAct() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Act
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov10" title="2">{
        proto.RegisterType((*AclRule)(nil), "auth.v1beta1.AclRule")
}</span>

func init() <span class="cov10" title="2">{ proto.RegisterFile("auth/v1beta1/acl_rule.proto", fileDescriptor_53927126401a53e9) }</span>

var fileDescriptor_53927126401a53e9 = []byte{
        // 170 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x4e, 0x2c, 0x2d, 0xc9,
        0xd0, 0x2f, 0x33, 0x4c, 0x4a, 0x2d, 0x49, 0x34, 0xd4, 0x4f, 0x4c, 0xce, 0x89, 0x2f, 0x2a, 0xcd,
        0x49, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0x49, 0xea, 0x41, 0x25, 0x95, 0xec,
        0xb9, 0xd8, 0x1d, 0x93, 0x73, 0x82, 0x4a, 0x73, 0x52, 0x85, 0x04, 0xb8, 0x98, 0x8b, 0x4b, 0x93,
        0x24, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83, 0x40, 0x4c, 0x90, 0x48, 0x7e, 0x52, 0x96, 0x04, 0x13,
        0x44, 0x24, 0x3f, 0x29, 0x0b, 0x24, 0x92, 0x98, 0x5c, 0x22, 0xc1, 0x0c, 0x11, 0x49, 0x4c, 0x2e,
        0x71, 0x8a, 0xe2, 0x12, 0xcf, 0xcc, 0xd7, 0x4b, 0xcd, 0x2b, 0x4e, 0x4d, 0x4c, 0x49, 0xd4, 0x43,
        0x36, 0xdb, 0x89, 0x07, 0x6a, 0x72, 0x00, 0xc8, 0xde, 0x00, 0xc6, 0x28, 0x6e, 0x90, 0x2c, 0x54,
        0x72, 0x11, 0x13, 0xb3, 0x63, 0x44, 0xc4, 0x2a, 0x26, 0x1e, 0x47, 0x90, 0x8e, 0x30, 0x43, 0x27,
        0x90, 0xe0, 0x29, 0x08, 0x37, 0x06, 0xca, 0x4d, 0x62, 0x03, 0xbb, 0xd8, 0x18, 0x10, 0x00, 0x00,
        0xff, 0xff, 0xa9, 0x9f, 0xa9, 0x60, 0xd0, 0x00, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: auth/v1beta1/o_auth_client.proto

package authv1beta1

import (
        fmt "fmt"
        math "math"

        proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// An OAuth client.
type OAuthClient struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        RedirectUris         []string `protobuf:"bytes,2,rep,name=redirect_uris,json=redirectUris,proto3" json:"redirect_uris,omitempty"`
        GrantTypes           []string `protobuf:"bytes,3,rep,name=grant_types,json=grantTypes,proto3" json:"grant_types,omitempty"`
        ResponseTypes        []string `protobuf:"bytes,4,rep,name=response_types,json=responseTypes,proto3" json:"response_types,omitempty"`
        Scopes               []string `protobuf:"bytes,5,rep,name=scopes,proto3" json:"scopes,omitempty"`
        Audiences            []string `protobuf:"bytes,6,rep,name=audiences,proto3" json:"audiences,omitempty"`
        Public               bool     `protobuf:"varint,7,opt,name=public,proto3" json:"public,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *OAuthClient) Reset()         <span class="cov0" title="0">{ *m = OAuthClient{} }</span>
func (m *OAuthClient) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*OAuthClient) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*OAuthClient) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_42f0bd39ac3c3851, []int{0}
}</span>

func (m *OAuthClient) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_OAuthClient.Unmarshal(m, b)
}</span>
func (m *OAuthClient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_OAuthClient.Marshal(b, m, deterministic)
}</span>
func (m *OAuthClient) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_OAuthClient.Merge(m, src)
}</span>
func (m *OAuthClient) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_OAuthClient.Size(m)
}</span>
func (m *OAuthClient) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_OAuthClient.DiscardUnknown(m)
}</span>

var xxx_messageInfo_OAuthClient proto.InternalMessageInfo

func (m *OAuthClient) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *OAuthClient) GetRedirectUris() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RedirectUris
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *OAuthClient) GetGrantTypes() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.GrantTypes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *OAuthClient) GetResponseTypes() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ResponseTypes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *OAuthClient) GetScopes() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Scopes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *OAuthClient) GetAudiences() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Audiences
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *OAuthClient) GetPublic() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Public
        }</span>
        <span class="cov0" title="0">return false</span>
}

func init() <span class="cov10" title="2">{
        proto.RegisterType((*OAuthClient)(nil), "auth.v1beta1.OAuthClient")
}</span>

func init() <span class="cov10" title="2">{ proto.RegisterFile("auth/v1beta1/o_auth_client.proto", fileDescriptor_42f0bd39ac3c3851) }</span>

var fileDescriptor_42f0bd39ac3c3851 = []byte{
        // 269 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x90, 0x4f, 0x4a, 0xc3, 0x40,
        0x14, 0x87, 0x49, 0xa2, 0xd1, 0xbc, 0xa4, 0x45, 0x66, 0xa1, 0x59, 0x08, 0x06, 0x45, 0xc8, 0x2a,
        0x25, 0x78, 0x82, 0xc6, 0x03, 0x58, 0x82, 0x4a, 0x11, 0x31, 0x4c, 0x92, 0x87, 0x1d, 0x28, 0x33,
        0x61, 0xfe, 0x08, 0x5e, 0xc7, 0xa5, 0x47, 0xf1, 0x04, 0x1e, 0x47, 0x66, 0x3a, 0xc5, 0x2e, 0xbf,
        0xef, 0xf7, 0xcd, 0x62, 0x1e, 0x14, 0xd4, 0xe8, 0xcd, 0xe2, 0xa3, 0xee, 0x51, 0xd3, 0x7a, 0x21,
        0x3a, 0x8b, 0xdd, 0xb0, 0x65, 0xc8, 0x75, 0x35, 0x49, 0xa1, 0x05, 0xc9, 0xac, 0xaa, 0x7c, 0x71,
        0xfd, 0x1b, 0x40, 0xfa, 0xb0, 0x34, 0x7a, 0x73, 0xef, 0x1a, 0x32, 0x87, 0x90, 0x8d, 0x79, 0x50,
        0x04, 0x65, 0xd2, 0x86, 0x6c, 0x24, 0x37, 0x30, 0x93, 0x38, 0x32, 0x89, 0x83, 0xee, 0x8c, 0x64,
        0x2a, 0x0f, 0x8b, 0xa8, 0x4c, 0xda, 0x6c, 0x2f, 0x9f, 0x24, 0x53, 0xe4, 0x0a, 0xd2, 0x77, 0x49,
        0xb9, 0xee, 0xf4, 0xe7, 0x84, 0x2a, 0x8f, 0x5c, 0x02, 0x4e, 0x3d, 0x5a, 0x43, 0x6e, 0x61, 0x2e,
        0x51, 0x4d, 0x82, 0x2b, 0xf4, 0xcd, 0x91, 0x6b, 0x66, 0x7b, 0xbb, 0xcb, 0xce, 0x21, 0x56, 0x83,
        0xb0, 0xf3, 0xb1, 0x9b, 0x3d, 0x91, 0x4b, 0x48, 0xa8, 0x19, 0x19, 0xf2, 0x01, 0x55, 0x1e, 0xbb,
        0xe9, 0x5f, 0xd8, 0x57, 0x93, 0xe9, 0xb7, 0x6c, 0xc8, 0x4f, 0x8a, 0xa0, 0x3c, 0x6d, 0x3d, 0x35,
        0x6f, 0x70, 0xc1, 0x44, 0x85, 0x5c, 0x21, 0x1d, 0x69, 0x75, 0xf8, 0xeb, 0xe6, 0xec, 0xe0, 0xcb,
        0x2b, 0x7b, 0x95, 0x55, 0xf0, 0x92, 0xda, 0xc2, 0x07, 0x5f, 0x61, 0xb4, 0x5c, 0xaf, 0xbf, 0xc3,
        0xcc, 0x66, 0xd5, 0x73, 0xdd, 0x58, 0xf9, 0xb3, 0xc3, 0x57, 0x8f, 0x7d, 0xec, 0xee, 0x79, 0xf7,
        0x17, 0x00, 0x00, 0xff, 0xff, 0xcf, 0x85, 0xad, 0x7c, 0x73, 0x01, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: auth/v1beta1/o_auth_clients_api.proto

package authv1beta1

import (
        fmt "fmt"
        math "math"

        proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Request body to list all available OAuth clients.
type ListClientsRequest struct {
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListClientsRequest) Reset()         <span class="cov0" title="0">{ *m = ListClientsRequest{} }</span>
func (m *ListClientsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListClientsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListClientsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{0}
}</span>

func (m *ListClientsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListClientsRequest.Unmarshal(m, b)
}</span>
func (m *ListClientsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListClientsRequest.Marshal(b, m, deterministic)
}</span>
func (m *ListClientsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListClientsRequest.Merge(m, src)
}</span>
func (m *ListClientsRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListClientsRequest.Size(m)
}</span>
func (m *ListClientsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListClientsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListClientsRequest proto.InternalMessageInfo

// Response body with a list of all available OAuth clients.
type ListClientsResponse struct {
        Clients              []*OAuthClient `protobuf:"bytes,1,rep,name=clients,proto3" json:"clients,omitempty"`
        XXX_NoUnkeyedLiteral struct{}       `json:"-"`
        XXX_unrecognized     []byte         `json:"-"`
        XXX_sizecache        int32          `json:"-"`
}

func (m *ListClientsResponse) Reset()         <span class="cov0" title="0">{ *m = ListClientsResponse{} }</span>
func (m *ListClientsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListClientsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListClientsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{1}
}</span>

func (m *ListClientsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListClientsResponse.Unmarshal(m, b)
}</span>
func (m *ListClientsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListClientsResponse.Marshal(b, m, deterministic)
}</span>
func (m *ListClientsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListClientsResponse.Merge(m, src)
}</span>
func (m *ListClientsResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListClientsResponse.Size(m)
}</span>
func (m *ListClientsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListClientsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListClientsResponse proto.InternalMessageInfo

func (m *ListClientsResponse) GetClients() []*OAuthClient <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Clients
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to get a single OAuth clients.
type GetClientRequest struct {
        // The id of the client to fetch. Required.
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetClientRequest) Reset()         <span class="cov0" title="0">{ *m = GetClientRequest{} }</span>
func (m *GetClientRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetClientRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetClientRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{2}
}</span>

func (m *GetClientRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetClientRequest.Unmarshal(m, b)
}</span>
func (m *GetClientRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetClientRequest.Marshal(b, m, deterministic)
}</span>
func (m *GetClientRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetClientRequest.Merge(m, src)
}</span>
func (m *GetClientRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetClientRequest.Size(m)
}</span>
func (m *GetClientRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetClientRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetClientRequest proto.InternalMessageInfo

func (m *GetClientRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response body with a single OAuth client.
type GetClientResponse struct {
        Client               *OAuthClient `protobuf:"bytes,1,opt,name=client,proto3" json:"client,omitempty"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *GetClientResponse) Reset()         <span class="cov0" title="0">{ *m = GetClientResponse{} }</span>
func (m *GetClientResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetClientResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetClientResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{3}
}</span>

func (m *GetClientResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetClientResponse.Unmarshal(m, b)
}</span>
func (m *GetClientResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetClientResponse.Marshal(b, m, deterministic)
}</span>
func (m *GetClientResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetClientResponse.Merge(m, src)
}</span>
func (m *GetClientResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetClientResponse.Size(m)
}</span>
func (m *GetClientResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetClientResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetClientResponse proto.InternalMessageInfo

func (m *GetClientResponse) GetClient() *OAuthClient <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Client
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to create a new OAuth client.
type CreateClientRequest struct {
        // The client to create. Required.
        Client *OAuthClient `protobuf:"bytes,1,opt,name=client,proto3" json:"client,omitempty"`
        // Client secret. Optional for public clients.
        Secret               string   `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreateClientRequest) Reset()         <span class="cov0" title="0">{ *m = CreateClientRequest{} }</span>
func (m *CreateClientRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateClientRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreateClientRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{4}
}</span>

func (m *CreateClientRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreateClientRequest.Unmarshal(m, b)
}</span>
func (m *CreateClientRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreateClientRequest.Marshal(b, m, deterministic)
}</span>
func (m *CreateClientRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreateClientRequest.Merge(m, src)
}</span>
func (m *CreateClientRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreateClientRequest.Size(m)
}</span>
func (m *CreateClientRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreateClientRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreateClientRequest proto.InternalMessageInfo

func (m *CreateClientRequest) GetClient() *OAuthClient <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Client
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *CreateClientRequest) GetSecret() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Secret
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response body with the newly created OAuth client.
type CreateClientResponse struct {
        Client               *OAuthClient `protobuf:"bytes,1,opt,name=client,proto3" json:"client,omitempty"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *CreateClientResponse) Reset()         <span class="cov0" title="0">{ *m = CreateClientResponse{} }</span>
func (m *CreateClientResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateClientResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreateClientResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{5}
}</span>

func (m *CreateClientResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreateClientResponse.Unmarshal(m, b)
}</span>
func (m *CreateClientResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreateClientResponse.Marshal(b, m, deterministic)
}</span>
func (m *CreateClientResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreateClientResponse.Merge(m, src)
}</span>
func (m *CreateClientResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreateClientResponse.Size(m)
}</span>
func (m *CreateClientResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreateClientResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreateClientResponse proto.InternalMessageInfo

func (m *CreateClientResponse) GetClient() *OAuthClient <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Client
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to update an OAuth client.
type UpdateClientRequest struct {
        // The client to update. Required.
        Client               *OAuthClient `protobuf:"bytes,1,opt,name=client,proto3" json:"client,omitempty"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *UpdateClientRequest) Reset()         <span class="cov0" title="0">{ *m = UpdateClientRequest{} }</span>
func (m *UpdateClientRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateClientRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateClientRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{6}
}</span>

func (m *UpdateClientRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateClientRequest.Unmarshal(m, b)
}</span>
func (m *UpdateClientRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateClientRequest.Marshal(b, m, deterministic)
}</span>
func (m *UpdateClientRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateClientRequest.Merge(m, src)
}</span>
func (m *UpdateClientRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateClientRequest.Size(m)
}</span>
func (m *UpdateClientRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateClientRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateClientRequest proto.InternalMessageInfo

func (m *UpdateClientRequest) GetClient() *OAuthClient <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Client
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Response body with the updated OAuth client.
type UpdateClientResponse struct {
        Client               *OAuthClient `protobuf:"bytes,1,opt,name=client,proto3" json:"client,omitempty"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *UpdateClientResponse) Reset()         <span class="cov0" title="0">{ *m = UpdateClientResponse{} }</span>
func (m *UpdateClientResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateClientResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateClientResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{7}
}</span>

func (m *UpdateClientResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateClientResponse.Unmarshal(m, b)
}</span>
func (m *UpdateClientResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateClientResponse.Marshal(b, m, deterministic)
}</span>
func (m *UpdateClientResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateClientResponse.Merge(m, src)
}</span>
func (m *UpdateClientResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateClientResponse.Size(m)
}</span>
func (m *UpdateClientResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateClientResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateClientResponse proto.InternalMessageInfo

func (m *UpdateClientResponse) GetClient() *OAuthClient <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Client
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to delete an OAuth client.
type DeleteClientRequest struct {
        // The client to delete. Required.
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteClientRequest) Reset()         <span class="cov0" title="0">{ *m = DeleteClientRequest{} }</span>
func (m *DeleteClientRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteClientRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteClientRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{8}
}</span>

func (m *DeleteClientRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteClientRequest.Unmarshal(m, b)
}</span>
func (m *DeleteClientRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteClientRequest.Marshal(b, m, deterministic)
}</span>
func (m *DeleteClientRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteClientRequest.Merge(m, src)
}</span>
func (m *DeleteClientRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteClientRequest.Size(m)
}</span>
func (m *DeleteClientRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteClientRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteClientRequest proto.InternalMessageInfo

func (m *DeleteClientRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response body with the deleted OAuth client.
type DeleteClientResponse struct {
        Client               *OAuthClient `protobuf:"bytes,1,opt,name=client,proto3" json:"client,omitempty"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *DeleteClientResponse) Reset()         <span class="cov0" title="0">{ *m = DeleteClientResponse{} }</span>
func (m *DeleteClientResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteClientResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteClientResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_2269de2967d2bebc, []int{9}
}</span>

func (m *DeleteClientResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteClientResponse.Unmarshal(m, b)
}</span>
func (m *DeleteClientResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteClientResponse.Marshal(b, m, deterministic)
}</span>
func (m *DeleteClientResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteClientResponse.Merge(m, src)
}</span>
func (m *DeleteClientResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteClientResponse.Size(m)
}</span>
func (m *DeleteClientResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteClientResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteClientResponse proto.InternalMessageInfo

func (m *DeleteClientResponse) GetClient() *OAuthClient <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Client
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov10" title="2">{
        proto.RegisterType((*ListClientsRequest)(nil), "auth.v1beta1.ListClientsRequest")
        proto.RegisterType((*ListClientsResponse)(nil), "auth.v1beta1.ListClientsResponse")
        proto.RegisterType((*GetClientRequest)(nil), "auth.v1beta1.GetClientRequest")
        proto.RegisterType((*GetClientResponse)(nil), "auth.v1beta1.GetClientResponse")
        proto.RegisterType((*CreateClientRequest)(nil), "auth.v1beta1.CreateClientRequest")
        proto.RegisterType((*CreateClientResponse)(nil), "auth.v1beta1.CreateClientResponse")
        proto.RegisterType((*UpdateClientRequest)(nil), "auth.v1beta1.UpdateClientRequest")
        proto.RegisterType((*UpdateClientResponse)(nil), "auth.v1beta1.UpdateClientResponse")
        proto.RegisterType((*DeleteClientRequest)(nil), "auth.v1beta1.DeleteClientRequest")
        proto.RegisterType((*DeleteClientResponse)(nil), "auth.v1beta1.DeleteClientResponse")
}</span>

func init() <span class="cov10" title="2">{
        proto.RegisterFile("auth/v1beta1/o_auth_clients_api.proto", fileDescriptor_2269de2967d2bebc)
}</span>

var fileDescriptor_2269de2967d2bebc = []byte{
        // 399 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x51, 0x4a, 0xeb, 0x40,
        0x14, 0x86, 0x49, 0x0a, 0xbd, 0xf4, 0x34, 0xdc, 0x7b, 0x9d, 0x04, 0xad, 0x79, 0xd0, 0x38, 0x50,
        0xe8, 0x53, 0x4a, 0xda, 0x15, 0xb4, 0x15, 0xb5, 0x52, 0xb0, 0x04, 0x2a, 0x45, 0x84, 0x9a, 0x36,
        0x07, 0x1a, 0x28, 0x4d, 0xec, 0x4c, 0x5d, 0x90, 0x8f, 0xae, 0xc0, 0x35, 0xb8, 0x2a, 0x49, 0x33,
        0x6a, 0x66, 0x4c, 0x0b, 0x16, 0x1f, 0xcf, 0xc9, 0x97, 0xff, 0xff, 0xe1, 0xfc, 0x0c, 0xd4, 0x83,
        0x35, 0x9f, 0x37, 0x9f, 0xbc, 0x29, 0xf2, 0xc0, 0x6b, 0xc6, 0x93, 0x74, 0x9c, 0xcc, 0x16, 0x11,
        0x2e, 0x39, 0x9b, 0x04, 0x49, 0xe4, 0x26, 0xab, 0x98, 0xc7, 0xc4, 0x48, 0xf7, 0xae, 0xc0, 0x6c,
        0x67, 0xfb, 0x4f, 0x19, 0x4f, 0x2d, 0x20, 0x83, 0x88, 0xf1, 0x5e, 0x26, 0xe4, 0xe3, 0xe3, 0x1a,
        0x19, 0xa7, 0xd7, 0x60, 0x4a, 0x5b, 0x96, 0xc4, 0x4b, 0x86, 0xa4, 0x0d, 0x7f, 0x84, 0x63, 0x4d,
        0x73, 0x4a, 0x8d, 0x6a, 0xeb, 0xd8, 0xcd, 0xdb, 0xb9, 0x37, 0x9d, 0x35, 0x9f, 0x67, 0x3f, 0xf9,
        0x1f, 0x24, 0xa5, 0xf0, 0xff, 0x12, 0x85, 0x94, 0xd0, 0x27, 0x7f, 0x41, 0x8f, 0xc2, 0x9a, 0xe6,
        0x68, 0x8d, 0x8a, 0xaf, 0x47, 0x21, 0xbd, 0x80, 0x83, 0x1c, 0x23, 0xdc, 0x3c, 0x28, 0x67, 0x1a,
        0x1b, 0x70, 0xa7, 0x99, 0x00, 0xe9, 0x03, 0x98, 0xbd, 0x15, 0x06, 0x1c, 0x65, 0xbb, 0x9f, 0x2b,
        0x91, 0x43, 0x28, 0x33, 0x9c, 0xad, 0x90, 0xd7, 0xf4, 0x4d, 0x4a, 0x31, 0xd1, 0x3e, 0x58, 0xb2,
        0xc3, 0xfe, 0x61, 0xaf, 0xc0, 0x1c, 0x25, 0xe1, 0x2f, 0x84, 0x4d, 0x43, 0xc9, 0x4a, 0xfb, 0x87,
        0xaa, 0x83, 0x79, 0x8e, 0x0b, 0x54, 0x43, 0xa9, 0x07, 0xeb, 0x83, 0x25, 0x63, 0x7b, 0x3b, 0xb6,
        0x5e, 0x4b, 0xf0, 0x2f, 0xb7, 0x67, 0x9d, 0x61, 0x9f, 0xf8, 0x50, 0xcd, 0xf5, 0x8f, 0x38, 0xb2,
        0xca, 0xf7, 0xc2, 0xda, 0x67, 0x3b, 0x08, 0x11, 0x6d, 0x00, 0x95, 0xcf, 0x8e, 0x91, 0x13, 0x99,
        0x57, 0x0b, 0x6a, 0x9f, 0x6e, 0xfd, 0x2e, 0xd4, 0x46, 0x60, 0xe4, 0x7b, 0x40, 0x94, 0x00, 0x05,
        0x2d, 0xb4, 0xe9, 0x2e, 0xe4, 0x4b, 0x36, 0x7f, 0x49, 0x55, 0xb6, 0xa0, 0x2f, 0xaa, 0x6c, 0x61,
        0x11, 0x46, 0x60, 0xe4, 0xcf, 0xa5, 0xca, 0x16, 0x5c, 0x5c, 0x95, 0x2d, 0xba, 0x76, 0x77, 0x0a,
        0x47, 0x51, 0xec, 0xe2, 0x92, 0x61, 0x10, 0x06, 0x12, 0xdf, 0xb5, 0xa4, 0x93, 0x26, 0xd1, 0x30,
        0x7d, 0x6d, 0x86, 0xda, 0x5d, 0x35, 0xa5, 0x04, 0xf4, 0xac, 0x97, 0x3a, 0xe3, 0xf1, 0x8b, 0x6e,
        0xa4, 0xa8, 0x7b, 0xeb, 0x75, 0xd3, 0xe5, 0x5b, 0x36, 0xde, 0x8b, 0x71, 0x5a, 0xde, 0xbc, 0x53,
        0xed, 0xf7, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x3a, 0xd8, 0xd1, 0x00, 0x05, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-twirp v5.8.0, DO NOT EDIT.
// source: auth/v1beta1/o_auth_clients_api.proto

package authv1beta1

import (
        bytes "bytes"
        strings "strings"

        context "context"

        fmt "fmt"

        ioutil "io/ioutil"

        http "net/http"

        strconv "strconv"

        jsonpb "github.com/golang/protobuf/jsonpb"

        proto "github.com/golang/protobuf/proto"

        twirp "github.com/twitchtv/twirp"

        ctxsetters "github.com/twitchtv/twirp/ctxsetters"
)

// =========================
// OAuthClientsAPI Interface
// =========================

// RPC API to manage OAuth clients.
type OAuthClientsAPI interface {
        // List all available OAuth clients.
        // OAuth scopes: oauth:client.read
        ListClients(context.Context, *ListClientsRequest) (*ListClientsResponse, error)

        // Get a single OAuth client.
        // OAuth scopes: oauth:client.read
        GetClient(context.Context, *GetClientRequest) (*GetClientResponse, error)

        // Add a new OAuth clients.
        // OAuth scopes: oauth:client.write
        CreateClient(context.Context, *CreateClientRequest) (*CreateClientResponse, error)

        // Update an OAuth client.
        // OAuth scopes: oauth:client.write
        UpdateClient(context.Context, *UpdateClientRequest) (*UpdateClientResponse, error)

        // Delete an OAuth clients.
        // OAuth scopes: oauth:client.write
        DeleteClient(context.Context, *DeleteClientRequest) (*DeleteClientResponse, error)
}

// ===============================
// OAuthClientsAPI Protobuf Client
// ===============================

type oAuthClientsAPIProtobufClient struct {
        client HTTPClient
        urls   [5]string
}

// NewOAuthClientsAPIProtobufClient creates a Protobuf client that implements the OAuthClientsAPI interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewOAuthClientsAPIProtobufClient(addr string, client HTTPClient) OAuthClientsAPI <span class="cov0" title="0">{
        prefix := urlBase(addr) + OAuthClientsAPIPathPrefix
        urls := [5]string{
                prefix + "ListClients",
                prefix + "GetClient",
                prefix + "CreateClient",
                prefix + "UpdateClient",
                prefix + "DeleteClient",
        }
        if httpClient, ok := client.(*http.Client); ok </span><span class="cov0" title="0">{
                return &amp;oAuthClientsAPIProtobufClient{
                        client: withoutRedirects(httpClient),
                        urls:   urls,
                }
        }</span>
        <span class="cov0" title="0">return &amp;oAuthClientsAPIProtobufClient{
                client: client,
                urls:   urls,
        }</span>
}

func (c *oAuthClientsAPIProtobufClient) ListClients(ctx context.Context, in *ListClientsRequest) (*ListClientsResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "ListClients")
        out := new(ListClientsResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[0], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthClientsAPIProtobufClient) GetClient(ctx context.Context, in *GetClientRequest) (*GetClientResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "GetClient")
        out := new(GetClientResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[1], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthClientsAPIProtobufClient) CreateClient(ctx context.Context, in *CreateClientRequest) (*CreateClientResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "CreateClient")
        out := new(CreateClientResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[2], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthClientsAPIProtobufClient) UpdateClient(ctx context.Context, in *UpdateClientRequest) (*UpdateClientResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "UpdateClient")
        out := new(UpdateClientResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[3], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthClientsAPIProtobufClient) DeleteClient(ctx context.Context, in *DeleteClientRequest) (*DeleteClientResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "DeleteClient")
        out := new(DeleteClientResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[4], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ===========================
// OAuthClientsAPI JSON Client
// ===========================

type oAuthClientsAPIJSONClient struct {
        client HTTPClient
        urls   [5]string
}

// NewOAuthClientsAPIJSONClient creates a JSON client that implements the OAuthClientsAPI interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewOAuthClientsAPIJSONClient(addr string, client HTTPClient) OAuthClientsAPI <span class="cov0" title="0">{
        prefix := urlBase(addr) + OAuthClientsAPIPathPrefix
        urls := [5]string{
                prefix + "ListClients",
                prefix + "GetClient",
                prefix + "CreateClient",
                prefix + "UpdateClient",
                prefix + "DeleteClient",
        }
        if httpClient, ok := client.(*http.Client); ok </span><span class="cov0" title="0">{
                return &amp;oAuthClientsAPIJSONClient{
                        client: withoutRedirects(httpClient),
                        urls:   urls,
                }
        }</span>
        <span class="cov0" title="0">return &amp;oAuthClientsAPIJSONClient{
                client: client,
                urls:   urls,
        }</span>
}

func (c *oAuthClientsAPIJSONClient) ListClients(ctx context.Context, in *ListClientsRequest) (*ListClientsResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "ListClients")
        out := new(ListClientsResponse)
        err := doJSONRequest(ctx, c.client, c.urls[0], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthClientsAPIJSONClient) GetClient(ctx context.Context, in *GetClientRequest) (*GetClientResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "GetClient")
        out := new(GetClientResponse)
        err := doJSONRequest(ctx, c.client, c.urls[1], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthClientsAPIJSONClient) CreateClient(ctx context.Context, in *CreateClientRequest) (*CreateClientResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "CreateClient")
        out := new(CreateClientResponse)
        err := doJSONRequest(ctx, c.client, c.urls[2], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthClientsAPIJSONClient) UpdateClient(ctx context.Context, in *UpdateClientRequest) (*UpdateClientResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "UpdateClient")
        out := new(UpdateClientResponse)
        err := doJSONRequest(ctx, c.client, c.urls[3], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *oAuthClientsAPIJSONClient) DeleteClient(ctx context.Context, in *DeleteClientRequest) (*DeleteClientResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithMethodName(ctx, "DeleteClient")
        out := new(DeleteClientResponse)
        err := doJSONRequest(ctx, c.client, c.urls[4], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ==============================
// OAuthClientsAPI Server Handler
// ==============================

type oAuthClientsAPIServer struct {
        OAuthClientsAPI
        hooks *twirp.ServerHooks
}

func NewOAuthClientsAPIServer(svc OAuthClientsAPI, hooks *twirp.ServerHooks) TwirpServer <span class="cov0" title="0">{
        return &amp;oAuthClientsAPIServer{
                OAuthClientsAPI: svc,
                hooks:           hooks,
        }
}</span>

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *oAuthClientsAPIServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) <span class="cov0" title="0">{
        writeError(ctx, resp, err, s.hooks)
}</span>

// OAuthClientsAPIPathPrefix is used for all URL paths on a twirp OAuthClientsAPI server.
// Requests are always: POST OAuthClientsAPIPathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const OAuthClientsAPIPathPrefix = "/twirp/auth.v1beta1.OAuthClientsAPI/"

func (s *oAuthClientsAPIServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        ctx := req.Context()
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "OAuthClientsAPI")
        ctx = ctxsetters.WithResponseWriter(ctx, resp)

        var err error
        ctx, err = callRequestReceived(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">if req.Method != "POST" </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
                err = badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">switch req.URL.Path </span>{
        case "/twirp/auth.v1beta1.OAuthClientsAPI/ListClients":<span class="cov0" title="0">
                s.serveListClients(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.OAuthClientsAPI/GetClient":<span class="cov0" title="0">
                s.serveGetClient(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.OAuthClientsAPI/CreateClient":<span class="cov0" title="0">
                s.serveCreateClient(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.OAuthClientsAPI/UpdateClient":<span class="cov0" title="0">
                s.serveUpdateClient(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.OAuthClientsAPI/DeleteClient":<span class="cov0" title="0">
                s.serveDeleteClient(ctx, resp, req)
                return</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
                err = badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, err)
                return</span>
        }
}

func (s *oAuthClientsAPIServer) serveListClients(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveListClientsJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveListClientsProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *oAuthClientsAPIServer) serveListClientsJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "ListClients")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(ListClientsRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *ListClientsResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.ListClients(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *ListClientsResponse and nil error while calling ListClients. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) serveListClientsProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "ListClients")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(ListClientsRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *ListClientsResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.ListClients(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *ListClientsResponse and nil error while calling ListClients. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) serveGetClient(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveGetClientJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveGetClientProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *oAuthClientsAPIServer) serveGetClientJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "GetClient")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(GetClientRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *GetClientResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.GetClient(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *GetClientResponse and nil error while calling GetClient. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) serveGetClientProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "GetClient")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(GetClientRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *GetClientResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.GetClient(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *GetClientResponse and nil error while calling GetClient. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) serveCreateClient(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveCreateClientJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveCreateClientProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *oAuthClientsAPIServer) serveCreateClientJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "CreateClient")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(CreateClientRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *CreateClientResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.CreateClient(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateClientResponse and nil error while calling CreateClient. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) serveCreateClientProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "CreateClient")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(CreateClientRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *CreateClientResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.CreateClient(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateClientResponse and nil error while calling CreateClient. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) serveUpdateClient(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveUpdateClientJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveUpdateClientProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *oAuthClientsAPIServer) serveUpdateClientJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "UpdateClient")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(UpdateClientRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *UpdateClientResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.UpdateClient(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdateClientResponse and nil error while calling UpdateClient. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) serveUpdateClientProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "UpdateClient")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(UpdateClientRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *UpdateClientResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.UpdateClient(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdateClientResponse and nil error while calling UpdateClient. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) serveDeleteClient(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveDeleteClientJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveDeleteClientProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *oAuthClientsAPIServer) serveDeleteClientJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "DeleteClient")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(DeleteClientRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *DeleteClientResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.DeleteClient(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteClientResponse and nil error while calling DeleteClient. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) serveDeleteClientProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "DeleteClient")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(DeleteClientRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *DeleteClientResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.OAuthClientsAPI.DeleteClient(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteClientResponse and nil error while calling DeleteClient. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *oAuthClientsAPIServer) ServiceDescriptor() ([]byte, int) <span class="cov0" title="0">{
        return twirpFileDescriptor1, 0
}</span>

func (s *oAuthClientsAPIServer) ProtocGenTwirpVersion() string <span class="cov0" title="0">{
        return "v5.8.0"
}</span>

func (s *oAuthClientsAPIServer) PathPrefix() string <span class="cov0" title="0">{
        return OAuthClientsAPIPathPrefix
}</span>

var twirpFileDescriptor1 = []byte{
        // 399 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x51, 0x4a, 0xeb, 0x40,
        0x14, 0x86, 0x49, 0x0a, 0xbd, 0xf4, 0x34, 0xdc, 0x7b, 0x9d, 0x04, 0xad, 0x79, 0xd0, 0x38, 0x50,
        0xe8, 0x53, 0x4a, 0xda, 0x15, 0xb4, 0x15, 0xb5, 0x52, 0xb0, 0x04, 0x2a, 0x45, 0x84, 0x9a, 0x36,
        0x07, 0x1a, 0x28, 0x4d, 0xec, 0x4c, 0x5d, 0x90, 0x8f, 0xae, 0xc0, 0x35, 0xb8, 0x2a, 0x49, 0x33,
        0x6a, 0x66, 0x4c, 0x0b, 0x16, 0x1f, 0xcf, 0xc9, 0x97, 0xff, 0xff, 0xe1, 0xfc, 0x0c, 0xd4, 0x83,
        0x35, 0x9f, 0x37, 0x9f, 0xbc, 0x29, 0xf2, 0xc0, 0x6b, 0xc6, 0x93, 0x74, 0x9c, 0xcc, 0x16, 0x11,
        0x2e, 0x39, 0x9b, 0x04, 0x49, 0xe4, 0x26, 0xab, 0x98, 0xc7, 0xc4, 0x48, 0xf7, 0xae, 0xc0, 0x6c,
        0x67, 0xfb, 0x4f, 0x19, 0x4f, 0x2d, 0x20, 0x83, 0x88, 0xf1, 0x5e, 0x26, 0xe4, 0xe3, 0xe3, 0x1a,
        0x19, 0xa7, 0xd7, 0x60, 0x4a, 0x5b, 0x96, 0xc4, 0x4b, 0x86, 0xa4, 0x0d, 0x7f, 0x84, 0x63, 0x4d,
        0x73, 0x4a, 0x8d, 0x6a, 0xeb, 0xd8, 0xcd, 0xdb, 0xb9, 0x37, 0x9d, 0x35, 0x9f, 0x67, 0x3f, 0xf9,
        0x1f, 0x24, 0xa5, 0xf0, 0xff, 0x12, 0x85, 0x94, 0xd0, 0x27, 0x7f, 0x41, 0x8f, 0xc2, 0x9a, 0xe6,
        0x68, 0x8d, 0x8a, 0xaf, 0x47, 0x21, 0xbd, 0x80, 0x83, 0x1c, 0x23, 0xdc, 0x3c, 0x28, 0x67, 0x1a,
        0x1b, 0x70, 0xa7, 0x99, 0x00, 0xe9, 0x03, 0x98, 0xbd, 0x15, 0x06, 0x1c, 0x65, 0xbb, 0x9f, 0x2b,
        0x91, 0x43, 0x28, 0x33, 0x9c, 0xad, 0x90, 0xd7, 0xf4, 0x4d, 0x4a, 0x31, 0xd1, 0x3e, 0x58, 0xb2,
        0xc3, 0xfe, 0x61, 0xaf, 0xc0, 0x1c, 0x25, 0xe1, 0x2f, 0x84, 0x4d, 0x43, 0xc9, 0x4a, 0xfb, 0x87,
        0xaa, 0x83, 0x79, 0x8e, 0x0b, 0x54, 0x43, 0xa9, 0x07, 0xeb, 0x83, 0x25, 0x63, 0x7b, 0x3b, 0xb6,
        0x5e, 0x4b, 0xf0, 0x2f, 0xb7, 0x67, 0x9d, 0x61, 0x9f, 0xf8, 0x50, 0xcd, 0xf5, 0x8f, 0x38, 0xb2,
        0xca, 0xf7, 0xc2, 0xda, 0x67, 0x3b, 0x08, 0x11, 0x6d, 0x00, 0x95, 0xcf, 0x8e, 0x91, 0x13, 0x99,
        0x57, 0x0b, 0x6a, 0x9f, 0x6e, 0xfd, 0x2e, 0xd4, 0x46, 0x60, 0xe4, 0x7b, 0x40, 0x94, 0x00, 0x05,
        0x2d, 0xb4, 0xe9, 0x2e, 0xe4, 0x4b, 0x36, 0x7f, 0x49, 0x55, 0xb6, 0xa0, 0x2f, 0xaa, 0x6c, 0x61,
        0x11, 0x46, 0x60, 0xe4, 0xcf, 0xa5, 0xca, 0x16, 0x5c, 0x5c, 0x95, 0x2d, 0xba, 0x76, 0x77, 0x0a,
        0x47, 0x51, 0xec, 0xe2, 0x92, 0x61, 0x10, 0x06, 0x12, 0xdf, 0xb5, 0xa4, 0x93, 0x26, 0xd1, 0x30,
        0x7d, 0x6d, 0x86, 0xda, 0x5d, 0x35, 0xa5, 0x04, 0xf4, 0xac, 0x97, 0x3a, 0xe3, 0xf1, 0x8b, 0x6e,
        0xa4, 0xa8, 0x7b, 0xeb, 0x75, 0xd3, 0xe5, 0x5b, 0x36, 0xde, 0x8b, 0x71, 0x5a, 0xde, 0xbc, 0x53,
        0xed, 0xf7, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x3a, 0xd8, 0xd1, 0x00, 0x05, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: auth/v1beta1/user.proto

package authv1beta1

import (
        fmt "fmt"
        math "math"

        proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// An OAuth user.
type User struct {
        Username             string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *User) Reset()         <span class="cov0" title="0">{ *m = User{} }</span>
func (m *User) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*User) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_64007389f379c5ba, []int{0}
}</span>

func (m *User) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_User.Unmarshal(m, b)
}</span>
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_User.Marshal(b, m, deterministic)
}</span>
func (m *User) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_User.Merge(m, src)
}</span>
func (m *User) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_User.Size(m)
}</span>
func (m *User) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_User.DiscardUnknown(m)
}</span>

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetUsername() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov10" title="2">{
        proto.RegisterType((*User)(nil), "auth.v1beta1.User")
}</span>

func init() <span class="cov10" title="2">{ proto.RegisterFile("auth/v1beta1/user.proto", fileDescriptor_64007389f379c5ba) }</span>

var fileDescriptor_64007389f379c5ba = []byte{
        // 143 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x4f, 0x2c, 0x2d, 0xc9,
        0xd0, 0x2f, 0x33, 0x4c, 0x4a, 0x2d, 0x49, 0x34, 0xd4, 0x2f, 0x2d, 0x4e, 0x2d, 0xd2, 0x2b, 0x28,
        0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x01, 0x49, 0xe8, 0x41, 0x25, 0x94, 0x94, 0xb8, 0x58, 0x42, 0x8b,
        0x53, 0x8b, 0x84, 0xa4, 0xb8, 0x38, 0x40, 0x6a, 0xf2, 0x12, 0x73, 0x53, 0x25, 0x18, 0x15, 0x18,
        0x35, 0x38, 0x83, 0xe0, 0x7c, 0xa7, 0x70, 0x2e, 0xf1, 0xcc, 0x7c, 0xbd, 0xd4, 0xbc, 0xe2, 0xd4,
        0xc4, 0x94, 0x44, 0x3d, 0x64, 0xed, 0x4e, 0x9c, 0x20, 0xcd, 0x01, 0x20, 0x73, 0x03, 0x18, 0xa3,
        0xb8, 0x41, 0x52, 0x50, 0x99, 0x45, 0x4c, 0xcc, 0x8e, 0x11, 0x11, 0xab, 0x98, 0x78, 0x1c, 0x41,
        0xca, 0xc3, 0x0c, 0x9d, 0x40, 0x82, 0xa7, 0x20, 0xdc, 0x18, 0x28, 0x37, 0x89, 0x0d, 0xec, 0x22,
        0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x16, 0x8f, 0x66, 0xb5, 0xac, 0x00, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: auth/v1beta1/users_api.proto

package authv1beta1

import (
        fmt "fmt"
        math "math"

        proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Request body to list all registered OAuth users.
type ListUsersRequest struct {
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListUsersRequest) Reset()         <span class="cov0" title="0">{ *m = ListUsersRequest{} }</span>
func (m *ListUsersRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListUsersRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListUsersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{0}
}</span>

func (m *ListUsersRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListUsersRequest.Unmarshal(m, b)
}</span>
func (m *ListUsersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListUsersRequest.Marshal(b, m, deterministic)
}</span>
func (m *ListUsersRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListUsersRequest.Merge(m, src)
}</span>
func (m *ListUsersRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListUsersRequest.Size(m)
}</span>
func (m *ListUsersRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListUsersRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListUsersRequest proto.InternalMessageInfo

// Response body with a list of all registered OAuth users.
type ListUsersResponse struct {
        Users                []*User  `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListUsersResponse) Reset()         <span class="cov0" title="0">{ *m = ListUsersResponse{} }</span>
func (m *ListUsersResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListUsersResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListUsersResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{1}
}</span>

func (m *ListUsersResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListUsersResponse.Unmarshal(m, b)
}</span>
func (m *ListUsersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListUsersResponse.Marshal(b, m, deterministic)
}</span>
func (m *ListUsersResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListUsersResponse.Merge(m, src)
}</span>
func (m *ListUsersResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListUsersResponse.Size(m)
}</span>
func (m *ListUsersResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListUsersResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListUsersResponse proto.InternalMessageInfo

func (m *ListUsersResponse) GetUsers() []*User <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Users
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to get a single OAuth user.
type GetUserRequest struct {
        // The username. Required.
        Username             string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserRequest) Reset()         <span class="cov0" title="0">{ *m = GetUserRequest{} }</span>
func (m *GetUserRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetUserRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{2}
}</span>

func (m *GetUserRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetUserRequest.Unmarshal(m, b)
}</span>
func (m *GetUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetUserRequest.Marshal(b, m, deterministic)
}</span>
func (m *GetUserRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetUserRequest.Merge(m, src)
}</span>
func (m *GetUserRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetUserRequest.Size(m)
}</span>
func (m *GetUserRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetUserRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetUserRequest proto.InternalMessageInfo

func (m *GetUserRequest) GetUsername() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response body with a single OAuth user.
type GetUserResponse struct {
        User                 *User    `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserResponse) Reset()         <span class="cov0" title="0">{ *m = GetUserResponse{} }</span>
func (m *GetUserResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetUserResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{3}
}</span>

func (m *GetUserResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetUserResponse.Unmarshal(m, b)
}</span>
func (m *GetUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetUserResponse.Marshal(b, m, deterministic)
}</span>
func (m *GetUserResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetUserResponse.Merge(m, src)
}</span>
func (m *GetUserResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetUserResponse.Size(m)
}</span>
func (m *GetUserResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetUserResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetUserResponse proto.InternalMessageInfo

func (m *GetUserResponse) GetUser() *User <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to create a new OAuth user.
type CreateUserRequest struct {
        // The user to create. Required.
        User *User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        // The user password. Required.
        Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreateUserRequest) Reset()         <span class="cov0" title="0">{ *m = CreateUserRequest{} }</span>
func (m *CreateUserRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateUserRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{4}
}</span>

func (m *CreateUserRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreateUserRequest.Unmarshal(m, b)
}</span>
func (m *CreateUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreateUserRequest.Marshal(b, m, deterministic)
}</span>
func (m *CreateUserRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreateUserRequest.Merge(m, src)
}</span>
func (m *CreateUserRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreateUserRequest.Size(m)
}</span>
func (m *CreateUserRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreateUserRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreateUserRequest proto.InternalMessageInfo

func (m *CreateUserRequest) GetUser() *User <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *CreateUserRequest) GetPassword() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response body with the newly created OAuth user.
type CreateUserResponse struct {
        User                 *User    `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreateUserResponse) Reset()         <span class="cov0" title="0">{ *m = CreateUserResponse{} }</span>
func (m *CreateUserResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateUserResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreateUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{5}
}</span>

func (m *CreateUserResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreateUserResponse.Unmarshal(m, b)
}</span>
func (m *CreateUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreateUserResponse.Marshal(b, m, deterministic)
}</span>
func (m *CreateUserResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreateUserResponse.Merge(m, src)
}</span>
func (m *CreateUserResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreateUserResponse.Size(m)
}</span>
func (m *CreateUserResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreateUserResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreateUserResponse proto.InternalMessageInfo

func (m *CreateUserResponse) GetUser() *User <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to update an OAuth user password.
// The target user is always the current authenticated user.
type UpdateUserPasswordRequest struct {
        // The new password. Required.
        Password             string   `protobuf:"bytes,1,opt,name=password,proto3" json:"password,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateUserPasswordRequest) Reset()         <span class="cov0" title="0">{ *m = UpdateUserPasswordRequest{} }</span>
func (m *UpdateUserPasswordRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateUserPasswordRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateUserPasswordRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{6}
}</span>

func (m *UpdateUserPasswordRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateUserPasswordRequest.Unmarshal(m, b)
}</span>
func (m *UpdateUserPasswordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateUserPasswordRequest.Marshal(b, m, deterministic)
}</span>
func (m *UpdateUserPasswordRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateUserPasswordRequest.Merge(m, src)
}</span>
func (m *UpdateUserPasswordRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateUserPasswordRequest.Size(m)
}</span>
func (m *UpdateUserPasswordRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateUserPasswordRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateUserPasswordRequest proto.InternalMessageInfo

func (m *UpdateUserPasswordRequest) GetPassword() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateUserPasswordResponse struct {
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateUserPasswordResponse) Reset()         <span class="cov0" title="0">{ *m = UpdateUserPasswordResponse{} }</span>
func (m *UpdateUserPasswordResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateUserPasswordResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateUserPasswordResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{7}
}</span>

func (m *UpdateUserPasswordResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateUserPasswordResponse.Unmarshal(m, b)
}</span>
func (m *UpdateUserPasswordResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateUserPasswordResponse.Marshal(b, m, deterministic)
}</span>
func (m *UpdateUserPasswordResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateUserPasswordResponse.Merge(m, src)
}</span>
func (m *UpdateUserPasswordResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateUserPasswordResponse.Size(m)
}</span>
func (m *UpdateUserPasswordResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateUserPasswordResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateUserPasswordResponse proto.InternalMessageInfo

// Request body to delete an OAuth user.
type DeleteUserRequest struct {
        // The username of the user to delete. Required.
        Username             string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteUserRequest) Reset()         <span class="cov0" title="0">{ *m = DeleteUserRequest{} }</span>
func (m *DeleteUserRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteUserRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{8}
}</span>

func (m *DeleteUserRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteUserRequest.Unmarshal(m, b)
}</span>
func (m *DeleteUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteUserRequest.Marshal(b, m, deterministic)
}</span>
func (m *DeleteUserRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteUserRequest.Merge(m, src)
}</span>
func (m *DeleteUserRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteUserRequest.Size(m)
}</span>
func (m *DeleteUserRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteUserRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteUserRequest proto.InternalMessageInfo

func (m *DeleteUserRequest) GetUsername() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response body with the deleted OAuth user.
type DeleteUserResponse struct {
        User                 *User    `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteUserResponse) Reset()         <span class="cov0" title="0">{ *m = DeleteUserResponse{} }</span>
func (m *DeleteUserResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteUserResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_7a0450201a6462a0, []int{9}
}</span>

func (m *DeleteUserResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteUserResponse.Unmarshal(m, b)
}</span>
func (m *DeleteUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteUserResponse.Marshal(b, m, deterministic)
}</span>
func (m *DeleteUserResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteUserResponse.Merge(m, src)
}</span>
func (m *DeleteUserResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteUserResponse.Size(m)
}</span>
func (m *DeleteUserResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteUserResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteUserResponse proto.InternalMessageInfo

func (m *DeleteUserResponse) GetUser() *User <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov10" title="2">{
        proto.RegisterType((*ListUsersRequest)(nil), "auth.v1beta1.ListUsersRequest")
        proto.RegisterType((*ListUsersResponse)(nil), "auth.v1beta1.ListUsersResponse")
        proto.RegisterType((*GetUserRequest)(nil), "auth.v1beta1.GetUserRequest")
        proto.RegisterType((*GetUserResponse)(nil), "auth.v1beta1.GetUserResponse")
        proto.RegisterType((*CreateUserRequest)(nil), "auth.v1beta1.CreateUserRequest")
        proto.RegisterType((*CreateUserResponse)(nil), "auth.v1beta1.CreateUserResponse")
        proto.RegisterType((*UpdateUserPasswordRequest)(nil), "auth.v1beta1.UpdateUserPasswordRequest")
        proto.RegisterType((*UpdateUserPasswordResponse)(nil), "auth.v1beta1.UpdateUserPasswordResponse")
        proto.RegisterType((*DeleteUserRequest)(nil), "auth.v1beta1.DeleteUserRequest")
        proto.RegisterType((*DeleteUserResponse)(nil), "auth.v1beta1.DeleteUserResponse")
}</span>

func init() <span class="cov10" title="2">{ proto.RegisterFile("auth/v1beta1/users_api.proto", fileDescriptor_7a0450201a6462a0) }</span>

var fileDescriptor_7a0450201a6462a0 = []byte{
        // 406 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x4e, 0xf2, 0x40,
        0x14, 0x4d, 0xe1, 0xfb, 0x81, 0x0b, 0xdf, 0xa7, 0xcc, 0x06, 0x9c, 0xa0, 0x92, 0x59, 0x68, 0x17,
        0xa6, 0x04, 0x5c, 0x18, 0x13, 0x5c, 0x80, 0x46, 0x63, 0x42, 0x62, 0x43, 0x82, 0x12, 0x35, 0x31,
        0x43, 0xb8, 0xd1, 0x26, 0x4a, 0x6b, 0xa7, 0xe8, 0xfb, 0xb8, 0xd4, 0x37, 0xf1, 0xa9, 0xcc, 0xb4,
        0x63, 0xe9, 0x0f, 0x55, 0x59, 0xde, 0x39, 0xe7, 0xdc, 0x73, 0x67, 0xce, 0x6d, 0xa1, 0xce, 0x67,
        0xde, 0x5d, 0xf3, 0xa9, 0x35, 0x46, 0x8f, 0xb7, 0x9a, 0x33, 0x81, 0xae, 0xb8, 0xe1, 0x8e, 0x65,
        0x38, 0xae, 0xed, 0xd9, 0xa4, 0x2c, 0x51, 0x43, 0xa1, 0xb4, 0x9a, 0xe2, 0x06, 0x34, 0x46, 0x60,
        0xb5, 0x6f, 0x09, 0x6f, 0x28, 0xd5, 0x03, 0x7c, 0x9c, 0xa1, 0xf0, 0xd8, 0x01, 0x54, 0x22, 0x67,
        0xc2, 0xb1, 0xa7, 0x02, 0x89, 0x0e, 0xbf, 0x7d, 0x8b, 0x9a, 0xd6, 0xc8, 0xeb, 0xa5, 0x36, 0x31,
        0xa2, 0xfd, 0x0d, 0xc9, 0x1d, 0x04, 0x04, 0xb6, 0x03, 0xff, 0x4f, 0xd0, 0x57, 0xab, 0x86, 0x84,
        0x42, 0x41, 0x42, 0x53, 0xfe, 0x80, 0x35, 0xad, 0xa1, 0xe9, 0xc5, 0x41, 0x58, 0xb3, 0x7d, 0x58,
        0x09, 0xd9, 0xca, 0x6a, 0x0b, 0x7e, 0x49, 0xd8, 0xa7, 0x2e, 0x76, 0xf2, 0x71, 0x76, 0x01, 0x95,
        0x43, 0x17, 0xb9, 0x87, 0x51, 0xaf, 0x1f, 0x8a, 0xe5, 0x4c, 0x0e, 0x17, 0xe2, 0xd9, 0x76, 0x27,
        0xb5, 0x5c, 0x30, 0xd3, 0x67, 0xcd, 0x3a, 0x40, 0xa2, 0x8d, 0x97, 0x1c, 0x6b, 0x0f, 0xd6, 0x86,
        0xce, 0x44, 0xa9, 0x4d, 0xd5, 0x33, 0xf2, 0x14, 0xa1, 0xad, 0x96, 0xb0, 0xad, 0x03, 0x5d, 0x24,
        0x0c, 0xec, 0x59, 0x13, 0x2a, 0x47, 0x78, 0x8f, 0xf1, 0xdb, 0x7e, 0xf5, 0xb2, 0x1d, 0x20, 0x51,
        0xc1, 0x72, 0xb7, 0x68, 0xbf, 0xe5, 0xa1, 0xe0, 0x6f, 0x40, 0xd7, 0x3c, 0x25, 0x7d, 0x28, 0x86,
        0x1b, 0x41, 0x36, 0xe2, 0x9a, 0xe4, 0xfa, 0xd0, 0xcd, 0x4c, 0x5c, 0x8d, 0x70, 0x0c, 0x7f, 0x55,
        0xe4, 0xa4, 0x1e, 0xe7, 0xc6, 0xf7, 0x86, 0xae, 0x67, 0xa0, 0xaa, 0xcf, 0x19, 0xc0, 0x3c, 0x26,
        0x92, 0xb0, 0x4d, 0x6d, 0x06, 0x6d, 0x64, 0x13, 0x54, 0xc3, 0x5b, 0x20, 0xe9, 0x00, 0xc8, 0x76,
        0xe2, 0x8d, 0xb2, 0xb2, 0xa5, 0xfa, 0xf7, 0xc4, 0xf9, 0xe4, 0xf3, 0x68, 0x92, 0x93, 0xa7, 0x52,
        0x4e, 0x4e, 0x9e, 0x4e, 0xb5, 0x77, 0x05, 0x55, 0xcb, 0x36, 0x70, 0x2a, 0x90, 0x4f, 0x78, 0x8c,
        0xdd, 0xfb, 0x17, 0xa4, 0xe8, 0x58, 0xa6, 0xfc, 0xe0, 0x4d, 0xed, 0xb2, 0x24, 0x61, 0x85, 0xbe,
        0xe4, 0xf2, 0xdd, 0xd1, 0xe8, 0x35, 0x57, 0xee, 0x4a, 0xc9, 0x79, 0xab, 0x27, 0x0f, 0xdf, 0x83,
        0xf2, 0x5a, 0x95, 0xe3, 0x3f, 0xfe, 0xaf, 0x62, 0xf7, 0x23, 0x00, 0x00, 0xff, 0xff, 0xae, 0x77,
        0x15, 0x4e, 0x71, 0x04, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-twirp v5.8.0, DO NOT EDIT.
// source: auth/v1beta1/users_api.proto

package authv1beta1

import (
        bytes "bytes"
        strings "strings"

        context "context"

        fmt "fmt"

        ioutil "io/ioutil"

        http "net/http"

        strconv "strconv"

        jsonpb "github.com/golang/protobuf/jsonpb"

        proto "github.com/golang/protobuf/proto"

        twirp "github.com/twitchtv/twirp"

        ctxsetters "github.com/twitchtv/twirp/ctxsetters"
)

// ==================
// UsersAPI Interface
// ==================

// RPC API to manage OAuth users.
type UsersAPI interface {
        // List all registered OAuth users.
        ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)

        // Get a single OAuth user.
        GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)

        // Create a new OAuth user with a password.
        CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)

        // Change a user password. Only callable by the user itself.
        UpdateUserPassword(context.Context, *UpdateUserPasswordRequest) (*UpdateUserPasswordResponse, error)

        // Delete a OAuth user.
        DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
}

// ========================
// UsersAPI Protobuf Client
// ========================

type usersAPIProtobufClient struct {
        client HTTPClient
        urls   [5]string
}

// NewUsersAPIProtobufClient creates a Protobuf client that implements the UsersAPI interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewUsersAPIProtobufClient(addr string, client HTTPClient) UsersAPI <span class="cov0" title="0">{
        prefix := urlBase(addr) + UsersAPIPathPrefix
        urls := [5]string{
                prefix + "ListUsers",
                prefix + "GetUser",
                prefix + "CreateUser",
                prefix + "UpdateUserPassword",
                prefix + "DeleteUser",
        }
        if httpClient, ok := client.(*http.Client); ok </span><span class="cov0" title="0">{
                return &amp;usersAPIProtobufClient{
                        client: withoutRedirects(httpClient),
                        urls:   urls,
                }
        }</span>
        <span class="cov0" title="0">return &amp;usersAPIProtobufClient{
                client: client,
                urls:   urls,
        }</span>
}

func (c *usersAPIProtobufClient) ListUsers(ctx context.Context, in *ListUsersRequest) (*ListUsersResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "ListUsers")
        out := new(ListUsersResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[0], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *usersAPIProtobufClient) GetUser(ctx context.Context, in *GetUserRequest) (*GetUserResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "GetUser")
        out := new(GetUserResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[1], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *usersAPIProtobufClient) CreateUser(ctx context.Context, in *CreateUserRequest) (*CreateUserResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "CreateUser")
        out := new(CreateUserResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[2], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *usersAPIProtobufClient) UpdateUserPassword(ctx context.Context, in *UpdateUserPasswordRequest) (*UpdateUserPasswordResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "UpdateUserPassword")
        out := new(UpdateUserPasswordResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[3], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *usersAPIProtobufClient) DeleteUser(ctx context.Context, in *DeleteUserRequest) (*DeleteUserResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "DeleteUser")
        out := new(DeleteUserResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[4], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ====================
// UsersAPI JSON Client
// ====================

type usersAPIJSONClient struct {
        client HTTPClient
        urls   [5]string
}

// NewUsersAPIJSONClient creates a JSON client that implements the UsersAPI interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewUsersAPIJSONClient(addr string, client HTTPClient) UsersAPI <span class="cov0" title="0">{
        prefix := urlBase(addr) + UsersAPIPathPrefix
        urls := [5]string{
                prefix + "ListUsers",
                prefix + "GetUser",
                prefix + "CreateUser",
                prefix + "UpdateUserPassword",
                prefix + "DeleteUser",
        }
        if httpClient, ok := client.(*http.Client); ok </span><span class="cov0" title="0">{
                return &amp;usersAPIJSONClient{
                        client: withoutRedirects(httpClient),
                        urls:   urls,
                }
        }</span>
        <span class="cov0" title="0">return &amp;usersAPIJSONClient{
                client: client,
                urls:   urls,
        }</span>
}

func (c *usersAPIJSONClient) ListUsers(ctx context.Context, in *ListUsersRequest) (*ListUsersResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "ListUsers")
        out := new(ListUsersResponse)
        err := doJSONRequest(ctx, c.client, c.urls[0], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *usersAPIJSONClient) GetUser(ctx context.Context, in *GetUserRequest) (*GetUserResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "GetUser")
        out := new(GetUserResponse)
        err := doJSONRequest(ctx, c.client, c.urls[1], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *usersAPIJSONClient) CreateUser(ctx context.Context, in *CreateUserRequest) (*CreateUserResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "CreateUser")
        out := new(CreateUserResponse)
        err := doJSONRequest(ctx, c.client, c.urls[2], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *usersAPIJSONClient) UpdateUserPassword(ctx context.Context, in *UpdateUserPasswordRequest) (*UpdateUserPasswordResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "UpdateUserPassword")
        out := new(UpdateUserPasswordResponse)
        err := doJSONRequest(ctx, c.client, c.urls[3], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *usersAPIJSONClient) DeleteUser(ctx context.Context, in *DeleteUserRequest) (*DeleteUserResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithMethodName(ctx, "DeleteUser")
        out := new(DeleteUserResponse)
        err := doJSONRequest(ctx, c.client, c.urls[4], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// =======================
// UsersAPI Server Handler
// =======================

type usersAPIServer struct {
        UsersAPI
        hooks *twirp.ServerHooks
}

func NewUsersAPIServer(svc UsersAPI, hooks *twirp.ServerHooks) TwirpServer <span class="cov0" title="0">{
        return &amp;usersAPIServer{
                UsersAPI: svc,
                hooks:    hooks,
        }
}</span>

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *usersAPIServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) <span class="cov0" title="0">{
        writeError(ctx, resp, err, s.hooks)
}</span>

// UsersAPIPathPrefix is used for all URL paths on a twirp UsersAPI server.
// Requests are always: POST UsersAPIPathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const UsersAPIPathPrefix = "/twirp/auth.v1beta1.UsersAPI/"

func (s *usersAPIServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        ctx := req.Context()
        ctx = ctxsetters.WithPackageName(ctx, "auth.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "UsersAPI")
        ctx = ctxsetters.WithResponseWriter(ctx, resp)

        var err error
        ctx, err = callRequestReceived(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">if req.Method != "POST" </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
                err = badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">switch req.URL.Path </span>{
        case "/twirp/auth.v1beta1.UsersAPI/ListUsers":<span class="cov0" title="0">
                s.serveListUsers(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.UsersAPI/GetUser":<span class="cov0" title="0">
                s.serveGetUser(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.UsersAPI/CreateUser":<span class="cov0" title="0">
                s.serveCreateUser(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.UsersAPI/UpdateUserPassword":<span class="cov0" title="0">
                s.serveUpdateUserPassword(ctx, resp, req)
                return</span>
        case "/twirp/auth.v1beta1.UsersAPI/DeleteUser":<span class="cov0" title="0">
                s.serveDeleteUser(ctx, resp, req)
                return</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
                err = badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, err)
                return</span>
        }
}

func (s *usersAPIServer) serveListUsers(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveListUsersJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveListUsersProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *usersAPIServer) serveListUsersJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "ListUsers")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(ListUsersRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *ListUsersResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.ListUsers(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *ListUsersResponse and nil error while calling ListUsers. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) serveListUsersProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "ListUsers")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(ListUsersRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *ListUsersResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.ListUsers(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *ListUsersResponse and nil error while calling ListUsers. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) serveGetUser(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveGetUserJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveGetUserProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *usersAPIServer) serveGetUserJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "GetUser")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(GetUserRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *GetUserResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.GetUser(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *GetUserResponse and nil error while calling GetUser. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) serveGetUserProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "GetUser")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(GetUserRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *GetUserResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.GetUser(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *GetUserResponse and nil error while calling GetUser. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) serveCreateUser(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveCreateUserJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveCreateUserProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *usersAPIServer) serveCreateUserJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "CreateUser")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(CreateUserRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *CreateUserResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.CreateUser(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateUserResponse and nil error while calling CreateUser. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) serveCreateUserProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "CreateUser")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(CreateUserRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *CreateUserResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.CreateUser(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateUserResponse and nil error while calling CreateUser. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) serveUpdateUserPassword(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveUpdateUserPasswordJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveUpdateUserPasswordProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *usersAPIServer) serveUpdateUserPasswordJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "UpdateUserPassword")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(UpdateUserPasswordRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *UpdateUserPasswordResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.UpdateUserPassword(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdateUserPasswordResponse and nil error while calling UpdateUserPassword. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) serveUpdateUserPasswordProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "UpdateUserPassword")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(UpdateUserPasswordRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *UpdateUserPasswordResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.UpdateUserPassword(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdateUserPasswordResponse and nil error while calling UpdateUserPassword. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) serveDeleteUser(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveDeleteUserJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveDeleteUserProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *usersAPIServer) serveDeleteUserJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "DeleteUser")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(DeleteUserRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *DeleteUserResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.DeleteUser(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteUserResponse and nil error while calling DeleteUser. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) serveDeleteUserProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "DeleteUser")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(DeleteUserRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *DeleteUserResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.UsersAPI.DeleteUser(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteUserResponse and nil error while calling DeleteUser. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *usersAPIServer) ServiceDescriptor() ([]byte, int) <span class="cov0" title="0">{
        return twirpFileDescriptor2, 0
}</span>

func (s *usersAPIServer) ProtocGenTwirpVersion() string <span class="cov0" title="0">{
        return "v5.8.0"
}</span>

func (s *usersAPIServer) PathPrefix() string <span class="cov0" title="0">{
        return UsersAPIPathPrefix
}</span>

var twirpFileDescriptor2 = []byte{
        // 406 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x4e, 0xf2, 0x40,
        0x14, 0x4d, 0xe1, 0xfb, 0x81, 0x0b, 0xdf, 0xa7, 0xcc, 0x06, 0x9c, 0xa0, 0x92, 0x59, 0x68, 0x17,
        0xa6, 0x04, 0x5c, 0x18, 0x13, 0x5c, 0x80, 0x46, 0x63, 0x42, 0x62, 0x43, 0x82, 0x12, 0x35, 0x31,
        0x43, 0xb8, 0xd1, 0x26, 0x4a, 0x6b, 0xa7, 0xe8, 0xfb, 0xb8, 0xd4, 0x37, 0xf1, 0xa9, 0xcc, 0xb4,
        0x63, 0xe9, 0x0f, 0x55, 0x59, 0xde, 0x39, 0xe7, 0xdc, 0x73, 0x67, 0xce, 0x6d, 0xa1, 0xce, 0x67,
        0xde, 0x5d, 0xf3, 0xa9, 0x35, 0x46, 0x8f, 0xb7, 0x9a, 0x33, 0x81, 0xae, 0xb8, 0xe1, 0x8e, 0x65,
        0x38, 0xae, 0xed, 0xd9, 0xa4, 0x2c, 0x51, 0x43, 0xa1, 0xb4, 0x9a, 0xe2, 0x06, 0x34, 0x46, 0x60,
        0xb5, 0x6f, 0x09, 0x6f, 0x28, 0xd5, 0x03, 0x7c, 0x9c, 0xa1, 0xf0, 0xd8, 0x01, 0x54, 0x22, 0x67,
        0xc2, 0xb1, 0xa7, 0x02, 0x89, 0x0e, 0xbf, 0x7d, 0x8b, 0x9a, 0xd6, 0xc8, 0xeb, 0xa5, 0x36, 0x31,
        0xa2, 0xfd, 0x0d, 0xc9, 0x1d, 0x04, 0x04, 0xb6, 0x03, 0xff, 0x4f, 0xd0, 0x57, 0xab, 0x86, 0x84,
        0x42, 0x41, 0x42, 0x53, 0xfe, 0x80, 0x35, 0xad, 0xa1, 0xe9, 0xc5, 0x41, 0x58, 0xb3, 0x7d, 0x58,
        0x09, 0xd9, 0xca, 0x6a, 0x0b, 0x7e, 0x49, 0xd8, 0xa7, 0x2e, 0x76, 0xf2, 0x71, 0x76, 0x01, 0x95,
        0x43, 0x17, 0xb9, 0x87, 0x51, 0xaf, 0x1f, 0x8a, 0xe5, 0x4c, 0x0e, 0x17, 0xe2, 0xd9, 0x76, 0x27,
        0xb5, 0x5c, 0x30, 0xd3, 0x67, 0xcd, 0x3a, 0x40, 0xa2, 0x8d, 0x97, 0x1c, 0x6b, 0x0f, 0xd6, 0x86,
        0xce, 0x44, 0xa9, 0x4d, 0xd5, 0x33, 0xf2, 0x14, 0xa1, 0xad, 0x96, 0xb0, 0xad, 0x03, 0x5d, 0x24,
        0x0c, 0xec, 0x59, 0x13, 0x2a, 0x47, 0x78, 0x8f, 0xf1, 0xdb, 0x7e, 0xf5, 0xb2, 0x1d, 0x20, 0x51,
        0xc1, 0x72, 0xb7, 0x68, 0xbf, 0xe5, 0xa1, 0xe0, 0x6f, 0x40, 0xd7, 0x3c, 0x25, 0x7d, 0x28, 0x86,
        0x1b, 0x41, 0x36, 0xe2, 0x9a, 0xe4, 0xfa, 0xd0, 0xcd, 0x4c, 0x5c, 0x8d, 0x70, 0x0c, 0x7f, 0x55,
        0xe4, 0xa4, 0x1e, 0xe7, 0xc6, 0xf7, 0x86, 0xae, 0x67, 0xa0, 0xaa, 0xcf, 0x19, 0xc0, 0x3c, 0x26,
        0x92, 0xb0, 0x4d, 0x6d, 0x06, 0x6d, 0x64, 0x13, 0x54, 0xc3, 0x5b, 0x20, 0xe9, 0x00, 0xc8, 0x76,
        0xe2, 0x8d, 0xb2, 0xb2, 0xa5, 0xfa, 0xf7, 0xc4, 0xf9, 0xe4, 0xf3, 0x68, 0x92, 0x93, 0xa7, 0x52,
        0x4e, 0x4e, 0x9e, 0x4e, 0xb5, 0x77, 0x05, 0x55, 0xcb, 0x36, 0x70, 0x2a, 0x90, 0x4f, 0x78, 0x8c,
        0xdd, 0xfb, 0x17, 0xa4, 0xe8, 0x58, 0xa6, 0xfc, 0xe0, 0x4d, 0xed, 0xb2, 0x24, 0x61, 0x85, 0xbe,
        0xe4, 0xf2, 0xdd, 0xd1, 0xe8, 0x35, 0x57, 0xee, 0x4a, 0xc9, 0x79, 0xab, 0x27, 0x0f, 0xdf, 0x83,
        0xf2, 0x5a, 0x95, 0xe3, 0x3f, 0xfe, 0xaf, 0x62, 0xf7, 0x23, 0x00, 0x00, 0xff, 0xff, 0xae, 0x77,
        0x15, 0x4e, 0x71, 0x04, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: maven/v1beta1/maven_api.proto

package mavenv1beta1

import (
        fmt "fmt"
        math "math"

        proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Request body to list all available Maven repositories.
type ListReposRequest struct {
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListReposRequest) Reset()         <span class="cov0" title="0">{ *m = ListReposRequest{} }</span>
func (m *ListReposRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListReposRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListReposRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d05b97ef3a7f10c9, []int{0}
}</span>

func (m *ListReposRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListReposRequest.Unmarshal(m, b)
}</span>
func (m *ListReposRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListReposRequest.Marshal(b, m, deterministic)
}</span>
func (m *ListReposRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListReposRequest.Merge(m, src)
}</span>
func (m *ListReposRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListReposRequest.Size(m)
}</span>
func (m *ListReposRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListReposRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListReposRequest proto.InternalMessageInfo

// Response body with a list of all available Maven repositories.
type ListReposResponse struct {
        Repos                []*Repo  `protobuf:"bytes,1,rep,name=repos,proto3" json:"repos,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListReposResponse) Reset()         <span class="cov0" title="0">{ *m = ListReposResponse{} }</span>
func (m *ListReposResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListReposResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListReposResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d05b97ef3a7f10c9, []int{1}
}</span>

func (m *ListReposResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListReposResponse.Unmarshal(m, b)
}</span>
func (m *ListReposResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListReposResponse.Marshal(b, m, deterministic)
}</span>
func (m *ListReposResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListReposResponse.Merge(m, src)
}</span>
func (m *ListReposResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListReposResponse.Size(m)
}</span>
func (m *ListReposResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListReposResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListReposResponse proto.InternalMessageInfo

func (m *ListReposResponse) GetRepos() []*Repo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Repos
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to retrieve a Maven repository.
type GetRepoRequest struct {
        // ID of the repository to retrieve. Required.
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetRepoRequest) Reset()         <span class="cov0" title="0">{ *m = GetRepoRequest{} }</span>
func (m *GetRepoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetRepoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetRepoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d05b97ef3a7f10c9, []int{2}
}</span>

func (m *GetRepoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetRepoRequest.Unmarshal(m, b)
}</span>
func (m *GetRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetRepoRequest.Marshal(b, m, deterministic)
}</span>
func (m *GetRepoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetRepoRequest.Merge(m, src)
}</span>
func (m *GetRepoRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetRepoRequest.Size(m)
}</span>
func (m *GetRepoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetRepoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetRepoRequest proto.InternalMessageInfo

func (m *GetRepoRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response body with the requested Maven repository.
type GetRepoResponse struct {
        Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetRepoResponse) Reset()         <span class="cov0" title="0">{ *m = GetRepoResponse{} }</span>
func (m *GetRepoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetRepoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetRepoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d05b97ef3a7f10c9, []int{3}
}</span>

func (m *GetRepoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetRepoResponse.Unmarshal(m, b)
}</span>
func (m *GetRepoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetRepoResponse.Marshal(b, m, deterministic)
}</span>
func (m *GetRepoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetRepoResponse.Merge(m, src)
}</span>
func (m *GetRepoResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetRepoResponse.Size(m)
}</span>
func (m *GetRepoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetRepoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetRepoResponse proto.InternalMessageInfo

func (m *GetRepoResponse) GetRepo() *Repo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Repo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to create a new Maven repository.
type CreateRepoRequest struct {
        // The repository Group ID. Required.
        GroupId string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
        // The repository Artifact ID. Required.
        ArtifactId           string   `protobuf:"bytes,2,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreateRepoRequest) Reset()         <span class="cov0" title="0">{ *m = CreateRepoRequest{} }</span>
func (m *CreateRepoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateRepoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreateRepoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d05b97ef3a7f10c9, []int{4}
}</span>

func (m *CreateRepoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreateRepoRequest.Unmarshal(m, b)
}</span>
func (m *CreateRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreateRepoRequest.Marshal(b, m, deterministic)
}</span>
func (m *CreateRepoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreateRepoRequest.Merge(m, src)
}</span>
func (m *CreateRepoRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreateRepoRequest.Size(m)
}</span>
func (m *CreateRepoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreateRepoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreateRepoRequest proto.InternalMessageInfo

func (m *CreateRepoRequest) GetGroupId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.GroupId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CreateRepoRequest) GetArtifactId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ArtifactId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response body with the newly created Maven repository.
type CreateRepoResponse struct {
        Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreateRepoResponse) Reset()         <span class="cov0" title="0">{ *m = CreateRepoResponse{} }</span>
func (m *CreateRepoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateRepoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreateRepoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d05b97ef3a7f10c9, []int{5}
}</span>

func (m *CreateRepoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreateRepoResponse.Unmarshal(m, b)
}</span>
func (m *CreateRepoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreateRepoResponse.Marshal(b, m, deterministic)
}</span>
func (m *CreateRepoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreateRepoResponse.Merge(m, src)
}</span>
func (m *CreateRepoResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreateRepoResponse.Size(m)
}</span>
func (m *CreateRepoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreateRepoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreateRepoResponse proto.InternalMessageInfo

func (m *CreateRepoResponse) GetRepo() *Repo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Repo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request body to retrieve a Maven repository.
type DeleteRepoRequest struct {
        // ID of the repository to retrieve. Required.
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRepoRequest) Reset()         <span class="cov0" title="0">{ *m = DeleteRepoRequest{} }</span>
func (m *DeleteRepoRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteRepoRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteRepoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d05b97ef3a7f10c9, []int{6}
}</span>

func (m *DeleteRepoRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRepoRequest.Unmarshal(m, b)
}</span>
func (m *DeleteRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRepoRequest.Marshal(b, m, deterministic)
}</span>
func (m *DeleteRepoRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteRepoRequest.Merge(m, src)
}</span>
func (m *DeleteRepoRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRepoRequest.Size(m)
}</span>
func (m *DeleteRepoRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteRepoRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteRepoRequest proto.InternalMessageInfo

func (m *DeleteRepoRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response body with the requested Maven repository.
type DeleteRepoResponse struct {
        Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRepoResponse) Reset()         <span class="cov0" title="0">{ *m = DeleteRepoResponse{} }</span>
func (m *DeleteRepoResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteRepoResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteRepoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_d05b97ef3a7f10c9, []int{7}
}</span>

func (m *DeleteRepoResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRepoResponse.Unmarshal(m, b)
}</span>
func (m *DeleteRepoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRepoResponse.Marshal(b, m, deterministic)
}</span>
func (m *DeleteRepoResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteRepoResponse.Merge(m, src)
}</span>
func (m *DeleteRepoResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteRepoResponse.Size(m)
}</span>
func (m *DeleteRepoResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteRepoResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteRepoResponse proto.InternalMessageInfo

func (m *DeleteRepoResponse) GetRepo() *Repo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Repo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov10" title="2">{
        proto.RegisterType((*ListReposRequest)(nil), "maven.v1beta1.ListReposRequest")
        proto.RegisterType((*ListReposResponse)(nil), "maven.v1beta1.ListReposResponse")
        proto.RegisterType((*GetRepoRequest)(nil), "maven.v1beta1.GetRepoRequest")
        proto.RegisterType((*GetRepoResponse)(nil), "maven.v1beta1.GetRepoResponse")
        proto.RegisterType((*CreateRepoRequest)(nil), "maven.v1beta1.CreateRepoRequest")
        proto.RegisterType((*CreateRepoResponse)(nil), "maven.v1beta1.CreateRepoResponse")
        proto.RegisterType((*DeleteRepoRequest)(nil), "maven.v1beta1.DeleteRepoRequest")
        proto.RegisterType((*DeleteRepoResponse)(nil), "maven.v1beta1.DeleteRepoResponse")
}</span>

func init() <span class="cov10" title="2">{ proto.RegisterFile("maven/v1beta1/maven_api.proto", fileDescriptor_d05b97ef3a7f10c9) }</span>

var fileDescriptor_d05b97ef3a7f10c9 = []byte{
        // 379 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xdf, 0x4e, 0xea, 0x40,
        0x10, 0xc6, 0xd3, 0x72, 0xce, 0x01, 0x86, 0x03, 0xe7, 0xb0, 0xde, 0xd4, 0x26, 0x48, 0xad, 0x17,
        0xe2, 0x4d, 0x09, 0x78, 0x67, 0x82, 0x89, 0x68, 0xa2, 0x24, 0xa2, 0xd8, 0x0b, 0x43, 0x8c, 0x09,
        0x59, 0xec, 0x68, 0x9a, 0x28, 0xad, 0xdd, 0x85, 0x07, 0xf2, 0xd2, 0x47, 0xe1, 0xa9, 0xcc, 0x6e,
        0x57, 0xe8, 0x9f, 0x60, 0xc2, 0xe5, 0xcc, 0xf7, 0x9b, 0x6f, 0x66, 0x67, 0xb2, 0xd0, 0x78, 0xa3,
        0x0b, 0x9c, 0xb5, 0x17, 0x9d, 0x29, 0x72, 0xda, 0x69, 0xcb, 0x68, 0x42, 0x43, 0xdf, 0x09, 0xa3,
        0x80, 0x07, 0xa4, 0x2a, 0x13, 0x8e, 0x92, 0x4d, 0x23, 0x4d, 0x47, 0x18, 0x06, 0x31, 0x68, 0x13,
        0xf8, 0x7f, 0xed, 0x33, 0xee, 0x62, 0x18, 0x30, 0x17, 0xdf, 0xe7, 0xc8, 0xb8, 0x7d, 0x0a, 0xf5,
        0x44, 0x8e, 0x85, 0xc1, 0x8c, 0x21, 0x39, 0x82, 0xdf, 0xa2, 0x8c, 0x19, 0x9a, 0x55, 0x68, 0x55,
        0xba, 0x3b, 0x4e, 0xaa, 0x83, 0x23, 0x60, 0x37, 0x26, 0x6c, 0x0b, 0x6a, 0x97, 0x28, 0xcb, 0x95,
        0x23, 0xa9, 0x81, 0xee, 0x7b, 0x86, 0x66, 0x69, 0xad, 0xb2, 0xab, 0xfb, 0x9e, 0x7d, 0x02, 0xff,
        0x56, 0x84, 0xf2, 0x3f, 0x84, 0x5f, 0xa2, 0x5a, 0x42, 0x1b, 0xec, 0x25, 0x60, 0xdf, 0x42, 0xfd,
        0x3c, 0x42, 0xca, 0x31, 0xd9, 0x60, 0x17, 0x4a, 0x2f, 0x51, 0x30, 0x0f, 0x27, 0xab, 0x36, 0x45,
        0x19, 0x0f, 0x3c, 0xd2, 0x84, 0x0a, 0x8d, 0xb8, 0xff, 0x4c, 0x9f, 0xb8, 0x50, 0x75, 0xa9, 0xc2,
        0x77, 0x6a, 0xe0, 0xd9, 0x3d, 0x20, 0x49, 0xc3, 0x6d, 0xe7, 0x39, 0x80, 0xfa, 0x05, 0xbe, 0x62,
        0x7a, 0x9e, 0xec, 0x83, 0x7b, 0x40, 0x92, 0xd0, 0x96, 0x3d, 0xba, 0x4b, 0x1d, 0x4a, 0x43, 0x21,
        0x9e, 0x8d, 0x06, 0xe4, 0x06, 0xca, 0xab, 0xf3, 0x90, 0x66, 0xa6, 0x28, 0x7b, 0x4c, 0xd3, 0xda,
        0x0c, 0xa8, 0x29, 0xae, 0xa0, 0xa8, 0x8e, 0x41, 0x1a, 0x19, 0x38, 0x7d, 0x46, 0x73, 0x6f, 0x93,
        0xac, 0x9c, 0xee, 0x00, 0xd6, 0x9b, 0x24, 0xd9, 0xce, 0xb9, 0xab, 0x99, 0xfb, 0x3f, 0x10, 0x6b,
        0xcb, 0xf5, 0xe2, 0x72, 0x96, 0xb9, 0xc5, 0xe7, 0x2c, 0xf3, 0x5b, 0xef, 0x4f, 0xc0, 0xf0, 0x03,
        0x07, 0x67, 0x0c, 0xa9, 0x47, 0xd3, 0x78, 0xbf, 0x1a, 0x6f, 0x39, 0xf4, 0x47, 0xe2, 0x77, 0x8c,
        0xb4, 0x87, 0xbf, 0x52, 0x57, 0xf2, 0x87, 0x5e, 0x18, 0x8e, 0xc7, 0x9f, 0x7a, 0x4c, 0x39, 0xf7,
        0x9d, 0xbe, 0xc8, 0x2e, 0x55, 0xfc, 0xa8, 0xe2, 0xe9, 0x1f, 0xf9, 0xb5, 0x8e, 0xbf, 0x02, 0x00,
        0x00, 0xff, 0xff, 0xa5, 0xfe, 0xad, 0x63, 0xa4, 0x03, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-twirp v5.8.0, DO NOT EDIT.
// source: maven/v1beta1/maven_api.proto

/*
Package mavenv1beta1 is a generated twirp stub package.
This code was generated with github.com/twitchtv/twirp/protoc-gen-twirp v5.8.0.

It is generated from these files:
        maven/v1beta1/maven_api.proto
        maven/v1beta1/repo.proto
*/
package mavenv1beta1

import (
        bytes "bytes"
        strings "strings"

        context "context"

        fmt "fmt"

        ioutil "io/ioutil"

        http "net/http"

        strconv "strconv"

        jsonpb "github.com/golang/protobuf/jsonpb"

        proto "github.com/golang/protobuf/proto"

        twirp "github.com/twitchtv/twirp"

        ctxsetters "github.com/twitchtv/twirp/ctxsetters"

        // Imports only used by utility functions:

        io "io"

        json "encoding/json"

        url "net/url"
)

// ==================
// MavenAPI Interface
// ==================

// RPC API for interacting with Maven repositories.
type MavenAPI interface {
        // List all available Maven repositories.
        ListRepos(context.Context, *ListReposRequest) (*ListReposResponse, error)

        // Retrieve a Maven repository.
        GetRepo(context.Context, *GetRepoRequest) (*GetRepoResponse, error)

        // Create a new Maven repository.
        CreateRepo(context.Context, *CreateRepoRequest) (*CreateRepoResponse, error)

        // Delete a Maven repository.
        DeleteRepo(context.Context, *DeleteRepoRequest) (*DeleteRepoResponse, error)
}

// ========================
// MavenAPI Protobuf Client
// ========================

type mavenAPIProtobufClient struct {
        client HTTPClient
        urls   [4]string
}

// NewMavenAPIProtobufClient creates a Protobuf client that implements the MavenAPI interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewMavenAPIProtobufClient(addr string, client HTTPClient) MavenAPI <span class="cov0" title="0">{
        prefix := urlBase(addr) + MavenAPIPathPrefix
        urls := [4]string{
                prefix + "ListRepos",
                prefix + "GetRepo",
                prefix + "CreateRepo",
                prefix + "DeleteRepo",
        }
        if httpClient, ok := client.(*http.Client); ok </span><span class="cov0" title="0">{
                return &amp;mavenAPIProtobufClient{
                        client: withoutRedirects(httpClient),
                        urls:   urls,
                }
        }</span>
        <span class="cov0" title="0">return &amp;mavenAPIProtobufClient{
                client: client,
                urls:   urls,
        }</span>
}

func (c *mavenAPIProtobufClient) ListRepos(ctx context.Context, in *ListReposRequest) (*ListReposResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "maven.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "MavenAPI")
        ctx = ctxsetters.WithMethodName(ctx, "ListRepos")
        out := new(ListReposResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[0], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *mavenAPIProtobufClient) GetRepo(ctx context.Context, in *GetRepoRequest) (*GetRepoResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "maven.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "MavenAPI")
        ctx = ctxsetters.WithMethodName(ctx, "GetRepo")
        out := new(GetRepoResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[1], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *mavenAPIProtobufClient) CreateRepo(ctx context.Context, in *CreateRepoRequest) (*CreateRepoResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "maven.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "MavenAPI")
        ctx = ctxsetters.WithMethodName(ctx, "CreateRepo")
        out := new(CreateRepoResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[2], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *mavenAPIProtobufClient) DeleteRepo(ctx context.Context, in *DeleteRepoRequest) (*DeleteRepoResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "maven.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "MavenAPI")
        ctx = ctxsetters.WithMethodName(ctx, "DeleteRepo")
        out := new(DeleteRepoResponse)
        err := doProtobufRequest(ctx, c.client, c.urls[3], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ====================
// MavenAPI JSON Client
// ====================

type mavenAPIJSONClient struct {
        client HTTPClient
        urls   [4]string
}

// NewMavenAPIJSONClient creates a JSON client that implements the MavenAPI interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewMavenAPIJSONClient(addr string, client HTTPClient) MavenAPI <span class="cov0" title="0">{
        prefix := urlBase(addr) + MavenAPIPathPrefix
        urls := [4]string{
                prefix + "ListRepos",
                prefix + "GetRepo",
                prefix + "CreateRepo",
                prefix + "DeleteRepo",
        }
        if httpClient, ok := client.(*http.Client); ok </span><span class="cov0" title="0">{
                return &amp;mavenAPIJSONClient{
                        client: withoutRedirects(httpClient),
                        urls:   urls,
                }
        }</span>
        <span class="cov0" title="0">return &amp;mavenAPIJSONClient{
                client: client,
                urls:   urls,
        }</span>
}

func (c *mavenAPIJSONClient) ListRepos(ctx context.Context, in *ListReposRequest) (*ListReposResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "maven.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "MavenAPI")
        ctx = ctxsetters.WithMethodName(ctx, "ListRepos")
        out := new(ListReposResponse)
        err := doJSONRequest(ctx, c.client, c.urls[0], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *mavenAPIJSONClient) GetRepo(ctx context.Context, in *GetRepoRequest) (*GetRepoResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "maven.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "MavenAPI")
        ctx = ctxsetters.WithMethodName(ctx, "GetRepo")
        out := new(GetRepoResponse)
        err := doJSONRequest(ctx, c.client, c.urls[1], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *mavenAPIJSONClient) CreateRepo(ctx context.Context, in *CreateRepoRequest) (*CreateRepoResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "maven.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "MavenAPI")
        ctx = ctxsetters.WithMethodName(ctx, "CreateRepo")
        out := new(CreateRepoResponse)
        err := doJSONRequest(ctx, c.client, c.urls[2], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *mavenAPIJSONClient) DeleteRepo(ctx context.Context, in *DeleteRepoRequest) (*DeleteRepoResponse, error) <span class="cov0" title="0">{
        ctx = ctxsetters.WithPackageName(ctx, "maven.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "MavenAPI")
        ctx = ctxsetters.WithMethodName(ctx, "DeleteRepo")
        out := new(DeleteRepoResponse)
        err := doJSONRequest(ctx, c.client, c.urls[3], in, out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// =======================
// MavenAPI Server Handler
// =======================

type mavenAPIServer struct {
        MavenAPI
        hooks *twirp.ServerHooks
}

func NewMavenAPIServer(svc MavenAPI, hooks *twirp.ServerHooks) TwirpServer <span class="cov0" title="0">{
        return &amp;mavenAPIServer{
                MavenAPI: svc,
                hooks:    hooks,
        }
}</span>

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *mavenAPIServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) <span class="cov0" title="0">{
        writeError(ctx, resp, err, s.hooks)
}</span>

// MavenAPIPathPrefix is used for all URL paths on a twirp MavenAPI server.
// Requests are always: POST MavenAPIPathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const MavenAPIPathPrefix = "/twirp/maven.v1beta1.MavenAPI/"

func (s *mavenAPIServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        ctx := req.Context()
        ctx = ctxsetters.WithPackageName(ctx, "maven.v1beta1")
        ctx = ctxsetters.WithServiceName(ctx, "MavenAPI")
        ctx = ctxsetters.WithResponseWriter(ctx, resp)

        var err error
        ctx, err = callRequestReceived(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">if req.Method != "POST" </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
                err = badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">switch req.URL.Path </span>{
        case "/twirp/maven.v1beta1.MavenAPI/ListRepos":<span class="cov0" title="0">
                s.serveListRepos(ctx, resp, req)
                return</span>
        case "/twirp/maven.v1beta1.MavenAPI/GetRepo":<span class="cov0" title="0">
                s.serveGetRepo(ctx, resp, req)
                return</span>
        case "/twirp/maven.v1beta1.MavenAPI/CreateRepo":<span class="cov0" title="0">
                s.serveCreateRepo(ctx, resp, req)
                return</span>
        case "/twirp/maven.v1beta1.MavenAPI/DeleteRepo":<span class="cov0" title="0">
                s.serveDeleteRepo(ctx, resp, req)
                return</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
                err = badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, err)
                return</span>
        }
}

func (s *mavenAPIServer) serveListRepos(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveListReposJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveListReposProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *mavenAPIServer) serveListReposJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "ListRepos")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(ListReposRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *ListReposResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.MavenAPI.ListRepos(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *ListReposResponse and nil error while calling ListRepos. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *mavenAPIServer) serveListReposProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "ListRepos")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(ListReposRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *ListReposResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.MavenAPI.ListRepos(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *ListReposResponse and nil error while calling ListRepos. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *mavenAPIServer) serveGetRepo(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveGetRepoJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveGetRepoProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *mavenAPIServer) serveGetRepoJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "GetRepo")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(GetRepoRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *GetRepoResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.MavenAPI.GetRepo(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *GetRepoResponse and nil error while calling GetRepo. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *mavenAPIServer) serveGetRepoProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "GetRepo")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(GetRepoRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *GetRepoResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.MavenAPI.GetRepo(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *GetRepoResponse and nil error while calling GetRepo. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *mavenAPIServer) serveCreateRepo(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveCreateRepoJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveCreateRepoProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *mavenAPIServer) serveCreateRepoJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "CreateRepo")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(CreateRepoRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *CreateRepoResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.MavenAPI.CreateRepo(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateRepoResponse and nil error while calling CreateRepo. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *mavenAPIServer) serveCreateRepoProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "CreateRepo")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(CreateRepoRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *CreateRepoResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.MavenAPI.CreateRepo(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateRepoResponse and nil error while calling CreateRepo. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *mavenAPIServer) serveDeleteRepo(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        header := req.Header.Get("Content-Type")
        i := strings.Index(header, ";")
        if i == -1 </span><span class="cov0" title="0">{
                i = len(header)
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(header[:i])) </span>{
        case "application/json":<span class="cov0" title="0">
                s.serveDeleteRepoJSON(ctx, resp, req)</span>
        case "application/protobuf":<span class="cov0" title="0">
                s.serveDeleteRepoProtobuf(ctx, resp, req)</span>
        default:<span class="cov0" title="0">
                msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
                twerr := badRouteError(msg, req.Method, req.URL.Path)
                s.writeError(ctx, resp, twerr)</span>
        }
}

func (s *mavenAPIServer) serveDeleteRepoJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "DeleteRepo")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">reqContent := new(DeleteRepoRequest)
        unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the json request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *DeleteRepoResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.MavenAPI.DeleteRepo(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteRepoResponse and nil error while calling DeleteRepo. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        var buf bytes.Buffer
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(&amp;buf, respContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        respBytes := buf.Bytes()
        resp.Header().Set("Content-Type", "application/json")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)

        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *mavenAPIServer) serveDeleteRepoProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        var err error
        ctx = ctxsetters.WithMethodName(ctx, "DeleteRepo")
        ctx, err = callRequestRouted(ctx, s.hooks)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>

        <span class="cov0" title="0">buf, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to read request body"))
                return
        }</span>
        <span class="cov0" title="0">reqContent := new(DeleteRepoRequest)
        if err = proto.Unmarshal(buf, reqContent); err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
                return
        }</span>

        // Call service method
        <span class="cov0" title="0">var respContent *DeleteRepoResponse
        func() </span><span class="cov0" title="0">{
                defer ensurePanicResponses(ctx, resp, s.hooks)
                respContent, err = s.MavenAPI.DeleteRepo(ctx, reqContent)
        }</span>()

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, err)
                return
        }</span>
        <span class="cov0" title="0">if respContent == nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteRepoResponse and nil error while calling DeleteRepo. nil responses are not supported"))
                return
        }</span>

        <span class="cov0" title="0">ctx = callResponsePrepared(ctx, s.hooks)

        respBytes, err := proto.Marshal(respContent)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
                return
        }</span>

        <span class="cov0" title="0">ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
        resp.Header().Set("Content-Type", "application/protobuf")
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
        resp.WriteHeader(http.StatusOK)
        if n, err := resp.Write(respBytes); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
                twerr := twirp.NewError(twirp.Unknown, msg)
                callError(ctx, s.hooks, twerr)
        }</span>
        <span class="cov0" title="0">callResponseSent(ctx, s.hooks)</span>
}

func (s *mavenAPIServer) ServiceDescriptor() ([]byte, int) <span class="cov0" title="0">{
        return twirpFileDescriptor0, 0
}</span>

func (s *mavenAPIServer) ProtocGenTwirpVersion() string <span class="cov0" title="0">{
        return "v5.8.0"
}</span>

func (s *mavenAPIServer) PathPrefix() string <span class="cov0" title="0">{
        return MavenAPIPathPrefix
}</span>

// =====
// Utils
// =====

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
//
// HTTPClient implementations should not follow redirects. Redirects are
// automatically disabled if *(net/http).Client is passed to client
// constructors. See the withoutRedirects function in this file for more
// details.
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// TwirpServer is the interface generated server structs will support: they're
// HTTP handlers with additional methods for accessing metadata about the
// service. Those accessors are a low-level API for building reflection tools.
// Most people can think of TwirpServers as just http.Handlers.
type TwirpServer interface {
        http.Handler
        // ServiceDescriptor returns gzipped bytes describing the .proto file that
        // this service was generated from. Once unzipped, the bytes can be
        // unmarshalled as a
        // github.com/golang/protobuf/protoc-gen-go/descriptor.FileDescriptorProto.
        //
        // The returned integer is the index of this particular service within that
        // FileDescriptorProto's 'Service' slice of ServiceDescriptorProtos. This is a
        // low-level field, expected to be used for reflection.
        ServiceDescriptor() ([]byte, int)
        // ProtocGenTwirpVersion is the semantic version string of the version of
        // twirp used to generate this file.
        ProtocGenTwirpVersion() string
        // PathPrefix returns the HTTP URL path prefix for all methods handled by this
        // service. This can be used with an HTTP mux to route twirp requests
        // alongside non-twirp requests on one HTTP listener.
        PathPrefix() string
}

// WriteError writes an HTTP response with a valid Twirp error format (code, msg, meta).
// Useful outside of the Twirp server (e.g. http middleware), but does not trigger hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func WriteError(resp http.ResponseWriter, err error) <span class="cov0" title="0">{
        writeError(context.Background(), resp, err, nil)
}</span>

// writeError writes Twirp errors in the response and triggers hooks.
func writeError(ctx context.Context, resp http.ResponseWriter, err error, hooks *twirp.ServerHooks) <span class="cov0" title="0">{
        // Non-twirp errors are wrapped as Internal (default)
        twerr, ok := err.(twirp.Error)
        if !ok </span><span class="cov0" title="0">{
                twerr = twirp.InternalErrorWith(err)
        }</span>

        <span class="cov0" title="0">statusCode := twirp.ServerHTTPStatusFromErrorCode(twerr.Code())
        ctx = ctxsetters.WithStatusCode(ctx, statusCode)
        ctx = callError(ctx, hooks, twerr)

        respBody := marshalErrorToJSON(twerr)

        resp.Header().Set("Content-Type", "application/json") // Error responses are always JSON
        resp.Header().Set("Content-Length", strconv.Itoa(len(respBody)))
        resp.WriteHeader(statusCode) // set HTTP status code and send response

        _, writeErr := resp.Write(respBody)
        if writeErr != nil </span><span class="cov0" title="0">{
                // We have three options here. We could log the error, call the Error
                // hook, or just silently ignore the error.
                //
                // Logging is unacceptable because we don't have a user-controlled
                // logger; writing out to stderr without permission is too rude.
                //
                // Calling the Error hook would confuse users: it would mean the Error
                // hook got called twice for one request, which is likely to lead to
                // duplicated log messages and metrics, no matter how well we document
                // the behavior.
                //
                // Silently ignoring the error is our least-bad option. It's highly
                // likely that the connection is broken and the original 'err' says
                // so anyway.
                _ = writeErr
        }</span>

        <span class="cov0" title="0">callResponseSent(ctx, hooks)</span>
}

// urlBase helps ensure that addr specifies a scheme. If it is unparsable
// as a URL, it returns addr unchanged.
func urlBase(addr string) string <span class="cov0" title="0">{
        // If the addr specifies a scheme, use it. If not, default to
        // http. If url.Parse fails on it, return it unchanged.
        url, err := url.Parse(addr)
        if err != nil </span><span class="cov0" title="0">{
                return addr
        }</span>
        <span class="cov0" title="0">if url.Scheme == "" </span><span class="cov0" title="0">{
                url.Scheme = "http"
        }</span>
        <span class="cov0" title="0">return url.String()</span>
}

// getCustomHTTPReqHeaders retrieves a copy of any headers that are set in
// a context through the twirp.WithHTTPRequestHeaders function.
// If there are no headers set, or if they have the wrong type, nil is returned.
func getCustomHTTPReqHeaders(ctx context.Context) http.Header <span class="cov0" title="0">{
        header, ok := twirp.HTTPRequestHeaders(ctx)
        if !ok || header == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">copied := make(http.Header)
        for k, vv := range header </span><span class="cov0" title="0">{
                if vv == nil </span><span class="cov0" title="0">{
                        copied[k] = nil
                        continue</span>
                }
                <span class="cov0" title="0">copied[k] = make([]string, len(vv))
                copy(copied[k], vv)</span>
        }
        <span class="cov0" title="0">return copied</span>
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("POST", url, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req = req.WithContext(ctx)
        if customHeader := getCustomHTTPReqHeaders(ctx); customHeader != nil </span><span class="cov0" title="0">{
                req.Header = customHeader
        }</span>
        <span class="cov0" title="0">req.Header.Set("Accept", contentType)
        req.Header.Set("Content-Type", contentType)
        req.Header.Set("Twirp-Version", "v5.8.0")
        return req, nil</span>
}

// JSON serialization for errors
type twerrJSON struct {
        Code string            `json:"code"`
        Msg  string            `json:"msg"`
        Meta map[string]string `json:"meta,omitempty"`
}

// marshalErrorToJSON returns JSON from a twirp.Error, that can be used as HTTP error response body.
// If serialization fails, it will use a descriptive Internal error instead.
func marshalErrorToJSON(twerr twirp.Error) []byte <span class="cov0" title="0">{
        // make sure that msg is not too large
        msg := twerr.Msg()
        if len(msg) &gt; 1e6 </span><span class="cov0" title="0">{
                msg = msg[:1e6]
        }</span>

        <span class="cov0" title="0">tj := twerrJSON{
                Code: string(twerr.Code()),
                Msg:  msg,
                Meta: twerr.MetaMap(),
        }

        buf, err := json.Marshal(&amp;tj)
        if err != nil </span><span class="cov0" title="0">{
                buf = []byte("{\"type\": \"" + twirp.Internal + "\", \"msg\": \"There was an error but it could not be serialized into JSON\"}") // fallback
        }</span>

        <span class="cov0" title="0">return buf</span>
}

// errorFromResponse builds a twirp.Error from a non-200 HTTP response.
// If the response has a valid serialized Twirp error, then it's returned.
// If not, the response status code is used to generate a similar twirp
// error. See twirpErrorFromIntermediary for more info on intermediary errors.
func errorFromResponse(resp *http.Response) twirp.Error <span class="cov0" title="0">{
        statusCode := resp.StatusCode
        statusText := http.StatusText(statusCode)

        if isHTTPRedirect(statusCode) </span><span class="cov0" title="0">{
                // Unexpected redirect: it must be an error from an intermediary.
                // Twirp clients don't follow redirects automatically, Twirp only handles
                // POST requests, redirects should only happen on GET and HEAD requests.
                location := resp.Header.Get("Location")
                msg := fmt.Sprintf("unexpected HTTP status code %d %q received, Location=%q", statusCode, statusText, location)
                return twirpErrorFromIntermediary(statusCode, msg, location)
        }</span>

        <span class="cov0" title="0">respBodyBytes, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to read server error response body")
        }</span>
        <span class="cov0" title="0">var tj twerrJSON
        if err := json.Unmarshal(respBodyBytes, &amp;tj); err != nil </span><span class="cov0" title="0">{
                // Invalid JSON response; it must be an error from an intermediary.
                msg := fmt.Sprintf("Error from intermediary with HTTP status code %d %q", statusCode, statusText)
                return twirpErrorFromIntermediary(statusCode, msg, string(respBodyBytes))
        }</span>

        <span class="cov0" title="0">errorCode := twirp.ErrorCode(tj.Code)
        if !twirp.IsValidErrorCode(errorCode) </span><span class="cov0" title="0">{
                msg := "invalid type returned from server error response: " + tj.Code
                return twirp.InternalError(msg)
        }</span>

        <span class="cov0" title="0">twerr := twirp.NewError(errorCode, tj.Msg)
        for k, v := range tj.Meta </span><span class="cov0" title="0">{
                twerr = twerr.WithMeta(k, v)
        }</span>
        <span class="cov0" title="0">return twerr</span>
}

// twirpErrorFromIntermediary maps HTTP errors from non-twirp sources to twirp errors.
// The mapping is similar to gRPC: https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md.
// Returned twirp Errors have some additional metadata for inspection.
func twirpErrorFromIntermediary(status int, msg string, bodyOrLocation string) twirp.Error <span class="cov0" title="0">{
        var code twirp.ErrorCode
        if isHTTPRedirect(status) </span><span class="cov0" title="0">{ // 3xx
                code = twirp.Internal
        }</span> else<span class="cov0" title="0"> {
                switch status </span>{
                case 400:<span class="cov0" title="0"> // Bad Request
                        code = twirp.Internal</span>
                case 401:<span class="cov0" title="0"> // Unauthorized
                        code = twirp.Unauthenticated</span>
                case 403:<span class="cov0" title="0"> // Forbidden
                        code = twirp.PermissionDenied</span>
                case 404:<span class="cov0" title="0"> // Not Found
                        code = twirp.BadRoute</span>
                case 429, 502, 503, 504:<span class="cov0" title="0"> // Too Many Requests, Bad Gateway, Service Unavailable, Gateway Timeout
                        code = twirp.Unavailable</span>
                default:<span class="cov0" title="0"> // All other codes
                        code = twirp.Unknown</span>
                }
        }

        <span class="cov0" title="0">twerr := twirp.NewError(code, msg)
        twerr = twerr.WithMeta("http_error_from_intermediary", "true") // to easily know if this error was from intermediary
        twerr = twerr.WithMeta("status_code", strconv.Itoa(status))
        if isHTTPRedirect(status) </span><span class="cov0" title="0">{
                twerr = twerr.WithMeta("location", bodyOrLocation)
        }</span> else<span class="cov0" title="0"> {
                twerr = twerr.WithMeta("body", bodyOrLocation)
        }</span>
        <span class="cov0" title="0">return twerr</span>
}

func isHTTPRedirect(status int) bool <span class="cov0" title="0">{
        return status &gt;= 300 &amp;&amp; status &lt;= 399
}</span>

// wrapInternal wraps an error with a prefix as an Internal error.
// The original error cause is accessible by github.com/pkg/errors.Cause.
func wrapInternal(err error, prefix string) twirp.Error <span class="cov0" title="0">{
        return twirp.InternalErrorWith(&amp;wrappedError{prefix: prefix, cause: err})
}</span>

type wrappedError struct {
        prefix string
        cause  error
}

func (e *wrappedError) Cause() error  <span class="cov0" title="0">{ return e.cause }</span>
func (e *wrappedError) Error() string <span class="cov0" title="0">{ return e.prefix + ": " + e.cause.Error() }</span>

// ensurePanicResponses makes sure that rpc methods causing a panic still result in a Twirp Internal
// error response (status 500), and error hooks are properly called with the panic wrapped as an error.
// The panic is re-raised so it can be handled normally with middleware.
func ensurePanicResponses(ctx context.Context, resp http.ResponseWriter, hooks *twirp.ServerHooks) <span class="cov0" title="0">{
        if r := recover(); r != nil </span><span class="cov0" title="0">{
                // Wrap the panic as an error so it can be passed to error hooks.
                // The original error is accessible from error hooks, but not visible in the response.
                err := errFromPanic(r)
                twerr := &amp;internalWithCause{msg: "Internal service panic", cause: err}
                // Actually write the error
                writeError(ctx, resp, twerr, hooks)
                // If possible, flush the error to the wire.
                f, ok := resp.(http.Flusher)
                if ok </span><span class="cov0" title="0">{
                        f.Flush()
                }</span>

                <span class="cov0" title="0">panic(r)</span>
        }
}

// errFromPanic returns the typed error if the recovered panic is an error, otherwise formats as error.
func errFromPanic(p interface{}) error <span class="cov0" title="0">{
        if err, ok := p.(error); ok </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("panic: %v", p)</span>
}

// internalWithCause is a Twirp Internal error wrapping an original error cause, accessible
// by github.com/pkg/errors.Cause, but the original error message is not exposed on Msg().
type internalWithCause struct {
        msg   string
        cause error
}

func (e *internalWithCause) Cause() error                                <span class="cov0" title="0">{ return e.cause }</span>
func (e *internalWithCause) Error() string                               <span class="cov0" title="0">{ return e.msg + ": " + e.cause.Error() }</span>
func (e *internalWithCause) Code() twirp.ErrorCode                       <span class="cov0" title="0">{ return twirp.Internal }</span>
func (e *internalWithCause) Msg() string                                 <span class="cov0" title="0">{ return e.msg }</span>
func (e *internalWithCause) Meta(key string) string                      <span class="cov0" title="0">{ return "" }</span>
func (e *internalWithCause) MetaMap() map[string]string                  <span class="cov0" title="0">{ return nil }</span>
func (e *internalWithCause) WithMeta(key string, val string) twirp.Error <span class="cov0" title="0">{ return e }</span>

// malformedRequestError is used when the twirp server cannot unmarshal a request
func malformedRequestError(msg string) twirp.Error <span class="cov0" title="0">{
        return twirp.NewError(twirp.Malformed, msg)
}</span>

// badRouteError is used when the twirp server cannot route a request
func badRouteError(msg string, method, url string) twirp.Error <span class="cov0" title="0">{
        err := twirp.NewError(twirp.BadRoute, msg)
        err = err.WithMeta("twirp_invalid_route", method+" "+url)
        return err
}</span>

// withoutRedirects makes sure that the POST request can not be redirected.
// The standard library will, by default, redirect requests (including POSTs) if it gets a 302 or
// 303 response, and also 301s in go1.8. It redirects by making a second request, changing the
// method to GET and removing the body. This produces very confusing error messages, so instead we
// set a redirect policy that always errors. This stops Go from executing the redirect.
//
// We have to be a little careful in case the user-provided http.Client has its own CheckRedirect
// policy - if so, we'll run through that policy first.
//
// Because this requires modifying the http.Client, we make a new copy of the client and return it.
func withoutRedirects(in *http.Client) *http.Client <span class="cov0" title="0">{
        copy := *in
        copy.CheckRedirect = func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                if in.CheckRedirect != nil </span><span class="cov0" title="0">{
                        // Run the input's redirect if it exists, in case it has side effects, but ignore any error it
                        // returns, since we want to use ErrUseLastResponse.
                        err := in.CheckRedirect(req, via)
                        _ = err // Silly, but this makes sure generated code passes errcheck -blank, which some people use.
                }</span>
                <span class="cov0" title="0">return http.ErrUseLastResponse</span>
        }
        <span class="cov0" title="0">return &amp;copy</span>
}

// doProtobufRequest makes a Protobuf request to the remote Twirp service.
func doProtobufRequest(ctx context.Context, client HTTPClient, url string, in, out proto.Message) (err error) <span class="cov0" title="0">{
        reqBodyBytes, err := proto.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to marshal proto request")
        }</span>
        <span class="cov0" title="0">reqBody := bytes.NewBuffer(reqBodyBytes)
        if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">req, err := newRequest(ctx, url, reqBody, "application/protobuf")
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "could not build request")
        }</span>
        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to do request")
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                cerr := resp.Body.Close()
                if err == nil &amp;&amp; cerr != nil </span><span class="cov0" title="0">{
                        err = wrapInternal(cerr, "failed to close response body")
                }</span>
        }()

        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return errorFromResponse(resp)
        }</span>

        <span class="cov0" title="0">respBodyBytes, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to read response body")
        }</span>
        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">if err = proto.Unmarshal(respBodyBytes, out); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to unmarshal proto response")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// doJSONRequest makes a JSON request to the remote Twirp service.
func doJSONRequest(ctx context.Context, client HTTPClient, url string, in, out proto.Message) (err error) <span class="cov0" title="0">{
        reqBody := bytes.NewBuffer(nil)
        marshaler := &amp;jsonpb.Marshaler{OrigName: true}
        if err = marshaler.Marshal(reqBody, in); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to marshal json request")
        }</span>
        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">req, err := newRequest(ctx, url, reqBody, "application/json")
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "could not build request")
        }</span>
        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to do request")
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                cerr := resp.Body.Close()
                if err == nil &amp;&amp; cerr != nil </span><span class="cov0" title="0">{
                        err = wrapInternal(cerr, "failed to close response body")
                }</span>
        }()

        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return errorFromResponse(resp)
        }</span>

        <span class="cov0" title="0">unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
        if err = unmarshaler.Unmarshal(resp.Body, out); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "failed to unmarshal json response")
        }</span>
        <span class="cov0" title="0">if err = ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return wrapInternal(err, "aborted because context was done")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Call twirp.ServerHooks.RequestReceived if the hook is available
func callRequestReceived(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) <span class="cov0" title="0">{
        if h == nil || h.RequestReceived == nil </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>
        <span class="cov0" title="0">return h.RequestReceived(ctx)</span>
}

// Call twirp.ServerHooks.RequestRouted if the hook is available
func callRequestRouted(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) <span class="cov0" title="0">{
        if h == nil || h.RequestRouted == nil </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>
        <span class="cov0" title="0">return h.RequestRouted(ctx)</span>
}

// Call twirp.ServerHooks.ResponsePrepared if the hook is available
func callResponsePrepared(ctx context.Context, h *twirp.ServerHooks) context.Context <span class="cov0" title="0">{
        if h == nil || h.ResponsePrepared == nil </span><span class="cov0" title="0">{
                return ctx
        }</span>
        <span class="cov0" title="0">return h.ResponsePrepared(ctx)</span>
}

// Call twirp.ServerHooks.ResponseSent if the hook is available
func callResponseSent(ctx context.Context, h *twirp.ServerHooks) <span class="cov0" title="0">{
        if h == nil || h.ResponseSent == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">h.ResponseSent(ctx)</span>
}

// Call twirp.ServerHooks.Error if the hook is available
func callError(ctx context.Context, h *twirp.ServerHooks, err twirp.Error) context.Context <span class="cov0" title="0">{
        if h == nil || h.Error == nil </span><span class="cov0" title="0">{
                return ctx
        }</span>
        <span class="cov0" title="0">return h.Error(ctx, err)</span>
}

var twirpFileDescriptor0 = []byte{
        // 379 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xdf, 0x4e, 0xea, 0x40,
        0x10, 0xc6, 0xd3, 0x72, 0xce, 0x01, 0x86, 0x03, 0xe7, 0xb0, 0xde, 0xd4, 0x26, 0x48, 0xad, 0x17,
        0xe2, 0x4d, 0x09, 0x78, 0x67, 0x82, 0x89, 0x68, 0xa2, 0x24, 0xa2, 0xd8, 0x0b, 0x43, 0x8c, 0x09,
        0x59, 0xec, 0x68, 0x9a, 0x28, 0xad, 0xdd, 0x85, 0x07, 0xf2, 0xd2, 0x47, 0xe1, 0xa9, 0xcc, 0x6e,
        0x57, 0xe8, 0x9f, 0x60, 0xc2, 0xe5, 0xcc, 0xf7, 0x9b, 0x6f, 0x66, 0x67, 0xb2, 0xd0, 0x78, 0xa3,
        0x0b, 0x9c, 0xb5, 0x17, 0x9d, 0x29, 0x72, 0xda, 0x69, 0xcb, 0x68, 0x42, 0x43, 0xdf, 0x09, 0xa3,
        0x80, 0x07, 0xa4, 0x2a, 0x13, 0x8e, 0x92, 0x4d, 0x23, 0x4d, 0x47, 0x18, 0x06, 0x31, 0x68, 0x13,
        0xf8, 0x7f, 0xed, 0x33, 0xee, 0x62, 0x18, 0x30, 0x17, 0xdf, 0xe7, 0xc8, 0xb8, 0x7d, 0x0a, 0xf5,
        0x44, 0x8e, 0x85, 0xc1, 0x8c, 0x21, 0x39, 0x82, 0xdf, 0xa2, 0x8c, 0x19, 0x9a, 0x55, 0x68, 0x55,
        0xba, 0x3b, 0x4e, 0xaa, 0x83, 0x23, 0x60, 0x37, 0x26, 0x6c, 0x0b, 0x6a, 0x97, 0x28, 0xcb, 0x95,
        0x23, 0xa9, 0x81, 0xee, 0x7b, 0x86, 0x66, 0x69, 0xad, 0xb2, 0xab, 0xfb, 0x9e, 0x7d, 0x02, 0xff,
        0x56, 0x84, 0xf2, 0x3f, 0x84, 0x5f, 0xa2, 0x5a, 0x42, 0x1b, 0xec, 0x25, 0x60, 0xdf, 0x42, 0xfd,
        0x3c, 0x42, 0xca, 0x31, 0xd9, 0x60, 0x17, 0x4a, 0x2f, 0x51, 0x30, 0x0f, 0x27, 0xab, 0x36, 0x45,
        0x19, 0x0f, 0x3c, 0xd2, 0x84, 0x0a, 0x8d, 0xb8, 0xff, 0x4c, 0x9f, 0xb8, 0x50, 0x75, 0xa9, 0xc2,
        0x77, 0x6a, 0xe0, 0xd9, 0x3d, 0x20, 0x49, 0xc3, 0x6d, 0xe7, 0x39, 0x80, 0xfa, 0x05, 0xbe, 0x62,
        0x7a, 0x9e, 0xec, 0x83, 0x7b, 0x40, 0x92, 0xd0, 0x96, 0x3d, 0xba, 0x4b, 0x1d, 0x4a, 0x43, 0x21,
        0x9e, 0x8d, 0x06, 0xe4, 0x06, 0xca, 0xab, 0xf3, 0x90, 0x66, 0xa6, 0x28, 0x7b, 0x4c, 0xd3, 0xda,
        0x0c, 0xa8, 0x29, 0xae, 0xa0, 0xa8, 0x8e, 0x41, 0x1a, 0x19, 0x38, 0x7d, 0x46, 0x73, 0x6f, 0x93,
        0xac, 0x9c, 0xee, 0x00, 0xd6, 0x9b, 0x24, 0xd9, 0xce, 0xb9, 0xab, 0x99, 0xfb, 0x3f, 0x10, 0x6b,
        0xcb, 0xf5, 0xe2, 0x72, 0x96, 0xb9, 0xc5, 0xe7, 0x2c, 0xf3, 0x5b, 0xef, 0x4f, 0xc0, 0xf0, 0x03,
        0x07, 0x67, 0x0c, 0xa9, 0x47, 0xd3, 0x78, 0xbf, 0x1a, 0x6f, 0x39, 0xf4, 0x47, 0xe2, 0x77, 0x8c,
        0xb4, 0x87, 0xbf, 0x52, 0x57, 0xf2, 0x87, 0x5e, 0x18, 0x8e, 0xc7, 0x9f, 0x7a, 0x4c, 0x39, 0xf7,
        0x9d, 0xbe, 0xc8, 0x2e, 0x55, 0xfc, 0xa8, 0xe2, 0xe9, 0x1f, 0xf9, 0xb5, 0x8e, 0xbf, 0x02, 0x00,
        0x00, 0xff, 0xff, 0xa5, 0xfe, 0xad, 0x63, 0xa4, 0x03, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Copyright 2019-2020 Enseada authors
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: maven/v1beta1/repo.proto

package mavenv1beta1

import (
        fmt "fmt"
        math "math"

        proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// A Maven repository.
type Repo struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        GroupId              string   `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
        ArtifactId           string   `protobuf:"bytes,3,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Repo) Reset()         <span class="cov0" title="0">{ *m = Repo{} }</span>
func (m *Repo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Repo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Repo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_1fa16ca33d8b98a2, []int{0}
}</span>

func (m *Repo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Repo.Unmarshal(m, b)
}</span>
func (m *Repo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Repo.Marshal(b, m, deterministic)
}</span>
func (m *Repo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Repo.Merge(m, src)
}</span>
func (m *Repo) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Repo.Size(m)
}</span>
func (m *Repo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Repo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Repo proto.InternalMessageInfo

func (m *Repo) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Repo) GetGroupId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.GroupId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Repo) GetArtifactId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ArtifactId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov10" title="2">{
        proto.RegisterType((*Repo)(nil), "maven.v1beta1.Repo")
}</span>

func init() <span class="cov10" title="2">{ proto.RegisterFile("maven/v1beta1/repo.proto", fileDescriptor_1fa16ca33d8b98a2) }</span>

var fileDescriptor_1fa16ca33d8b98a2 = []byte{
        // 183 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0xc8, 0x4d, 0x2c, 0x4b,
        0xcd, 0xd3, 0x2f, 0x33, 0x4c, 0x4a, 0x2d, 0x49, 0x34, 0xd4, 0x2f, 0x4a, 0x2d, 0xc8, 0xd7, 0x2b,
        0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x05, 0xcb, 0xe8, 0x41, 0x65, 0x94, 0x82, 0xb8, 0x58, 0x82,
        0x52, 0x0b, 0xf2, 0x85, 0xf8, 0xb8, 0x98, 0x32, 0x53, 0x24, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83,
        0x98, 0x32, 0x53, 0x84, 0x24, 0xb9, 0x38, 0xd2, 0x8b, 0xf2, 0x4b, 0x0b, 0xe2, 0x33, 0x53, 0x24,
        0x98, 0xc0, 0xa2, 0xec, 0x60, 0xbe, 0x67, 0x8a, 0x90, 0x3c, 0x17, 0x77, 0x62, 0x51, 0x49, 0x66,
        0x5a, 0x62, 0x72, 0x09, 0x48, 0x96, 0x19, 0x2c, 0xcb, 0x05, 0x13, 0xf2, 0x4c, 0x71, 0x8a, 0xe6,
        0x92, 0xc8, 0xcc, 0xd7, 0x4b, 0xcd, 0x2b, 0x4e, 0x4d, 0x4c, 0x49, 0xd4, 0x43, 0xb1, 0xcf, 0x89,
        0x13, 0x64, 0x5b, 0x00, 0xc8, 0x25, 0x01, 0x8c, 0x51, 0x3c, 0x60, 0x39, 0xa8, 0xd4, 0x22, 0x26,
        0x66, 0xdf, 0x88, 0x88, 0x55, 0x4c, 0xbc, 0xbe, 0x60, 0x0d, 0x61, 0x86, 0x4e, 0x20, 0xd1, 0x53,
        0x50, 0x7e, 0x0c, 0x94, 0x9f, 0xc4, 0x06, 0xf6, 0x86, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x82,
        0x19, 0x36, 0x6b, 0xe2, 0x00, 0x00, 0x00,
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
